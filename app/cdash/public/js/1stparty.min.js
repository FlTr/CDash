// assumes the ids of the sortable child elements
// are properly set
function getSortedElements(parent) {
  var positions = [];
  $(parent).children().each(function() {
    var pos = {};
    pos.id = $(this).attr('id');
    pos.position = $(this).index() + 1;
    positions.push(pos);
  });
  return positions;
}

$(document).ready(function () {
  // Initialize tab navigation
  $('#tabs a').tab();

  // Enable link to tab
  var url = document.location.toString();
  if (url.match('#/')) {
    $('.nav-tabs a[href=#'+url.split('#/')[1]+']').tab('show') ;
  }

  // Change hash for page-reload
  $('.nav-tabs a').on('shown', function (e) {
    angular.element(window).location.hash = e.target.hash;
  })

  $('#tabs a').click(function (e) {
    e.preventDefault();
    $(this).tab('show');
  });
});

function makeLineChart(elementName, inputData, project, anchor, sort) {
  jQuery(function(){

    // setup the chart
    var chart = $.jqplot (elementName, [inputData], {
      axes:{
        xaxis:{
          renderer: $.jqplot.DateAxisRenderer,
          tickOptions: {formatString:'%b %#d'},
        }
      },
      highlighter: {
        show: true,
        sizeAdjust: 7.5
      },
      cursor: {
        show: false
      }
    });

    $("#" + elementName).bind('jqplotDataClick',
      function (ev, seriesIndex, pointIndex, data) {
        // Get the date for this data point in the format that CDash expects.
        var d = new Date(data[0]);
        var day = ("0" + d.getDate()).slice(-2);
        var month = ("0" + (d.getMonth() + 1)).slice(-2);
        var year = d.getFullYear();
        var date = year + "-" + month + "-" + day;

        // Redirect the user to this project's index page for the given date.
        var url = "index.php?project=" + project + "&date=" + date;
        if (sort) {
          url += "&sort=" + sort;
        }
        if (anchor) {
          url += "##" + anchor;
        }
        window.open(url, '_blank');
      }
    );

    // Change X axis to tightly fit the data.
    var highest_value = chart.axes.xaxis._dataBounds.max;
    var lowest_value = chart.axes.xaxis._dataBounds.min;
    if (highest_value > lowest_value) {
      chart.axes.xaxis.max = highest_value;
      chart.axes.xaxis.min = lowest_value;
      chart.replot();
    }
  });
}

function makeBulletChart(chartName, elementName, min, avg, max, current,
                         previous, chartHeight) {
  // note that chartHeight is just for the chart itself (not the labels)
  var chart;
  nv.addGraph(function() {
    chart = nv.models.bulletChart()
    .options({
      margin: {top: 33, right: 10, bottom: 5, left: 5},
      height: chartHeight + 33
    });

    var chartData = {
      "ranges": [min, avg, max],
      "rangeLabels": ["Low", "Medium", "Satisfactory"],
      "measures": [current],
      "markers": [previous],
      };

    // This chart doesn't render without the marker, so instead of
    // leaving it off, we just relabel it to "Current" instead of
    // the default label of "Previous".
    if (previous == current) {
      chartData["markerLabels"] = ["Current"];
    }

    d3.select(elementName)
      .datum(chartData)
      .call(chart);
    return chart;
  });
}

var CDash = angular
.module('CDash', [
    'angular-clipboard',
    'ngAnimate',
    'ngFileUpload',
    'ui.sortable',
    'ui.bootstrap'
    ]);

angular.module('CDash').constant('VERSION', '1585070544784');
CDash.directive('autoComplete', function($parse) {
  return function(scope, element, attrs) {
    element.autocomplete({
      source: $parse(attrs.availableValues)(scope)
    });
  };
});

CDash.directive('build', function (VERSION) {
  return {
    templateUrl: 'build/views/partials/build_' + VERSION + '.html'
  }
});

CDash.directive('buildgroup', function (VERSION) {
  return {
    templateUrl: 'build/views/partials/buildgroup_' + VERSION + '.html'
  }
});

CDash.directive('convertToNumber', function() {
  return {
    require: 'ngModel',
    link: function(scope, element, attrs, ngModel) {
      ngModel.$parsers.push(function(val) {
        return parseInt(val, 10);
      });
      ngModel.$formatters.push(function(val) {
        return '' + val;
      });
    }
  };
});

CDash.directive('daterange', function (VERSION) {
  return {
    restrict: 'A',
    templateUrl: 'build/views/partials/daterange_' + VERSION + '.html',
    link: function (scope, element, attrs, ngModelCtrl) {
      var format = "yy-mm-dd",

      begin = element.find("#begin").datepicker({
        constrainInput: false,
        changeMonth: true,
        dateFormat: format,
        defaultDate: scope.cdash.date
      }).on( "change", function() {
        var date = getDate(this);
        if (date) {
          end.datepicker("option", "minDate", date);
        }
      }),

      end = element.find("#end").datepicker({
        constrainInput: false,
        changeMonth: true,
        dateFormat: format,
        defaultDate: scope.cdash.date
      }).on( "change", function() {
        var date = getDate(this);
        if (date) {
          begin.datepicker("option", "maxDate", date);
        }
      });

      function getDate(element) {
        var date;
        try {
          date = $.datepicker.parseDate(format, element.value);
        } catch( error ) {
          date = null;
        }
        return date;
      }
    }
  };
});

CDash.directive('onFinishRender', function ($timeout) {
  return {
    restrict: 'A',
    link: function (scope, element, attr) {
      if (scope.$last === true) {
        scope.$evalAsync(attr.onFinishRender);
      }
    }
  }
});

var timelineController =
  function TimelineChartController($http, $scope) {
    $scope.loading = true;

    query_parameters = {
      project: $scope.$parent.cdash.projectname,
      filterdata: $scope.$parent.cdash.filterdata
    };
    if ($scope.$parent.cdash.hasOwnProperty('begin') &&
        $scope.$parent.cdash.hasOwnProperty('end')) {
      query_parameters.begin = $scope.$parent.cdash.begin;
      query_parameters.end = $scope.$parent.cdash.end;
    } else {
      query_parameters.date = $scope.$parent.cdash.date;
    }
    if ($scope.$parent.cdash.hasOwnProperty('buildgroup')) {
      $scope.buildgroup = $scope.$parent.cdash.buildgroup;
      query_parameters.buildgroup = $scope.buildgroup;
    }
    $http({
      url: 'api/v1/timeline.php',
      method: 'GET',
      params: query_parameters
    }).then(function success(s) {
      $scope.timeline = s.data;
      $scope.error = false;
      $scope.finishSetup();
    }, function error(e) {
      $scope.error = e.data;
    }).finally(function() {
      $scope.loading = false;
    });


    $scope.finishSetup = function() {
      if ($scope.timeline === undefined || $scope.timeline.length === 0) {
        return;
      }

      // Construct an array of timestamps corresponding to our nightly start times.
      var nightly_start_times = Object.keys($scope.timeline.time_to_date);
      // Convert from string to int.
      $scope.nightly_start_times = nightly_start_times.map(function (x) {
        return Number(x);
      });

      nv.addGraph(function() {
        $scope.timechart = nv.models.stackedAreaChart()
          .x(function(d) { return d[0] })
          .y(function(d) { return d[1] })
          .interpolate("step-after")
          .margin({top: 30, right: 60, bottom: 30, left: 60})
          .rightAlignYAxis(false)
          .showControls(false)
          .showLegend(true)
          .showTotalInTooltip(false)
          .useInteractiveGuideline(true);

        if ($scope.timeline.hasOwnProperty('colors')) {
          $scope.timechart.color($scope.timeline.colors);
        }

        $scope.timechart.xAxis.showMaxMin(false);
        $scope.timechart_selection = d3.select('#timechart svg').datum($scope.timeline.data);
        $scope.timechart_selection.call($scope.timechart);

        $scope.timechart_selection
        .select(".nv-axislabel")
        .style('font-size', '16')
        .style('font-weight', 'bold');

        $scope.timechart.update();
        nv.utils.windowResize($scope.timechart.update);

        // Calculate how many ticks can comfortably fit on our X-axis.
        var bbox = d3.select(".nv-stackedAreaChart g rect").node().getBBox();
        var text_element = $scope.timechart_selection
        .append('text')
        .attr("class", "nvd3")
        .text('2999-12-31')
        .style('visibility', 'hidden');
        var label_width = text_element.node().getBBox().width;
        text_element.remove();
        var num_ticks = Math.floor(Math.round(bbox.width) / (Math.ceil(label_width) * 2));

        // Extract that many evenly spaced dates for our X-axis tick values.
        var nightly_start_times = $scope.nightly_start_times.slice(0);
        // Don't show the final X-axis tick because it represents one day
        // past our specified range.
        nightly_start_times.pop();
        if (nightly_start_times.length > num_ticks) {
          var tick_values = [nightly_start_times[0]];
          var interval = nightly_start_times.length / num_ticks;
          for (var i = 1; i < num_ticks; i++) {
            tick_values.push(nightly_start_times[Math.round(i * interval)]);
          }
        } else {
          var tick_values = nightly_start_times;
        }

        // Format x-axis labels as dates.
        $scope.timechart.xAxis
        .showMaxMin(false)
        .tickValues(tick_values)
        .tickFormat(function(d) {
          return $scope.timeline.time_to_date[d];
        });
        $scope.timechart.update();

        // Use d3.brush to allow the user to select a date range.
        $scope.timeline.brush = d3.svg.brush()
        .x($scope.timechart.xScale())
        .extent([$scope.timeline.extentstart, $scope.timeline.extentend])
        .on("brushstart", brushstart)
        .on("brushend", brushend);
        $scope.start_brushing = true;

        var brush_element = $scope.timechart_selection
        .select(".nv-areaWrap")
        .append("g")
        .attr("class", "brush")
        .call($scope.timeline.brush)
        .selectAll('rect')
        .attr('height', bbox.height)
        .attr('fill-opacity', '.125')
        .attr('stroke', '#fff');

        // Remove the brush background so mouseover events get passed through
        // to the underlying chart. This makes it so our tooltips still work.
        brush_element.select(".background").remove();

        $scope.computeSelectedDateRange();

        function brushstart() {
          // Work around a d3 bug where brushstart() gets called before
          // AND after brushend().
          if (!$scope.start_brushing) {
            $scope.start_brushing = true;
            return;
          }

          // Hide tooltips while moving the brush.
          d3.select('.nvtooltip').style('display', 'none');
          $scope.start_brushing = false;
        }

        // Snap to day boundaries.
        function brushend() {
          if (!d3.event.sourceEvent) return; // only transition after input

          // Use binary search to round to the nearest day.
          function find_closest_time (input_time, valid_times) {
            var mid;
            var lo = 0;
            var hi = valid_times.length - 1;
            while (hi - lo > 1) {
              mid = Math.floor ((lo + hi) / 2);
              if (valid_times[mid] < input_time) {
                lo = mid;
              } else {
                hi = mid;
              }
            }
            if (input_time - valid_times[lo] <= valid_times[hi] - input_time) {
              return valid_times[lo];
            }
            return valid_times[hi];
          }
          var extent = $scope.timeline.brush.extent();
          var new_extent = [];
          new_extent[0] = find_closest_time(extent[0], $scope.nightly_start_times);
          new_extent[1] = find_closest_time(extent[1], $scope.nightly_start_times);

          // Don't go out of bounds.
          if (new_extent[0] < $scope.timeline.min) {
            new_extent[0] = $scope.timeline.min;
          }
          if (new_extent[1] > $scope.timeline.max) {
            new_extent[1] = $scope.timeline.max;
          }

          var min_changed = extent[0] != new_extent[0];
          var max_changed = extent[1] != new_extent[1];
          // Don't collapse the extent down to nothing.
          // At minimum it should span a single testing day.
          if (new_extent[0] == new_extent[1]) {
            if (min_changed) {
              new_extent[0] = new_extent[1] - 1000 * 3600 * 24;
            } else if (max_changed) {
              new_extent[1] = new_extent[0] + 1000 * 3600 * 24;
            }
          }

          // Smoothly move the brush if necessary.
          if (new_extent[0] != extent[0] || new_extent[1] != extent[1]) {
            d3.select(this).transition()
              .duration($scope.timeline.brush.empty() ? 0 : 750)
              .call($scope.timeline.brush.extent(new_extent))
              .call($scope.timeline.brush.event);
          }

          $scope.computeSelectedDateRange();
          d3.select('.nvtooltip').style('display', 'block');
        }

        return $scope.timechart;
      });
    };

    $scope.computeSelectedDateRange = function() {
      // Record our currently selected time range in terms of testing days.
      var extent = $scope.timeline.brush.extent();
      var timestamps = Object.keys($scope.timeline.time_to_date);

      // extent[0] and extent[1] should both already be set to timestamps that
      // represent testing day boundaries.  These boundaries are the keys of our
      // time_to_date object.  If our extent is found to hold invalid values
      // we record the beginning and/or end of our testing date range instead.
      if (timestamps.indexOf(String(extent[0])) === -1) {
        $scope.$parent.cdash.begin_date = $scope.timeline.time_to_date[Number(timestamps[0])];
      } else {
        $scope.$parent.cdash.begin_date = $scope.timeline.time_to_date[extent[0]];
      }

      // The end of our range is pointing at the end of the testing day.
      // We want to report the beginning of this day instead, so we grab the date
      // corresponding to the previous timestamp.
      idx = timestamps.indexOf(String(extent[1]));
      if (idx > 0) {
        $scope.$parent.cdash.end_date = $scope.timeline.time_to_date[timestamps[idx - 1]];
      } else {
        $scope.$parent.cdash.end_date = $scope.timeline.time_to_date[Number(timestamps[timestamps.length - 1])];
      }
    };

    $scope.updateSelection = function() {
      // Defer to the parent controller's implementation of this function
      // if one exists.
      if (typeof $scope.$parent.updateSelection === 'function') {
        return $scope.$parent.updateSelection();
      }

      var uri = '//' + location.host + location.pathname + '?project=' + $scope.cdash.projectname_encoded;

      if ($scope.hasOwnProperty('buildgroup')) {
        uri += '&buildgroup=' + $scope.buildgroup;
      }

      // Include date range from time chart.
      if ($scope.cdash.begin_date == $scope.cdash.end_date) {
        uri += '&date=' + $scope.cdash.begin_date;
      } else {
        uri += '&begin=' + $scope.cdash.begin_date + '&end=' + $scope.cdash.end_date;
      }

      window.location = uri;
    };
};

CDash.directive('timeline', function (VERSION) {
  return {
    restrict: 'A',
    templateUrl: 'build/views/partials/timeline_' + VERSION + '.html',
    controller: timelineController
  };
});

// Keep subprojects with missing fields at the bottom of the list.
// Shared between index.html & viewSubProjects.html
CDash.filter("showEmptySubProjectsLast", function () {
  return function (subprojects, sortField) {
    if (!angular.isArray(subprojects)) return;
    if (!sortField) return subprojects;
    if (angular.isArray(sortField)) {
      if (sortField.length < 1) {
        return subprojects;
      }
      sortField = sortField[0];
    }
    if (sortField.charAt(0) == '-') {
      sortField = sortField.substring(1);
    }

    // First weed out the subprojects that are completely empty.
    // These will stay at the bottom of the table.
    var empty = subprojects.filter(function (subproject) {
      return (subproject.nconfigureerror == 0 && subproject.nconfigurewarning == 0 && subproject.nconfigurepass == 0 && subproject.nbuilderror == 0 && subproject.nbuildwarning == 0 && subproject.nbuildpass == 0 && subproject.ntestfail == 0 && subproject.ntestnotrun == 0 && subproject.ntestpass == 0);
    });

    var nonempty = subprojects.filter(function (subproject) {
      return (subproject.nconfigureerror != 0 || subproject.nconfigurewarning != 0 || subproject.nconfigurepass != 0 || subproject.nbuilderror != 0 || subproject.nbuildwarning != 0 || subproject.nbuildpass != 0 || subproject.ntestfail != 0 || subproject.ntestnotrun != 0 || subproject.ntestpass != 0);
    });

    switch (sortField) {
      case 'name':
      case 'lastsubmission':
      default:
        return subprojects;
        break;

      case 'nconfigureerror':
      case 'nconfigurewarning':
      case 'nconfigurepass':
        var present = nonempty.filter(function (subproject) {
          return (subproject.nconfigureerror != 0 || subproject.nconfigurewarning != 0 || subproject.nconfigurepass != 0);
        });
        var missing = nonempty.filter(function (subproject) {
          return (subproject.nconfigureerror == 0 && subproject.nconfigurewarning == 0 && subproject.nconfigurepass == 0);
        });
        present = present.concat(missing);
        break;

      case 'nbuilderror':
      case 'nbuildwarning':
      case 'nbuildpass':
        var present = nonempty.filter(function (subproject) {
          return (subproject.nbuilderror != 0 || subproject.nbuildwarning != 0 || subproject.nbuildpass != 0);
        });
        var missing = nonempty.filter(function (subproject) {
          return (subproject.nbuilderror == 0 && subproject.nbuildwarning == 0 && subproject.nbuildpass == 0);
        });
        present = present.concat(missing);
        break;

      case 'ntestfail':
      case 'ntestnotrun':
      case 'ntestpass':
        var present = nonempty.filter(function (subproject) {
          return (subproject.ntestfail != 0 || subproject.ntestnotrun != 0 || subproject.ntestpass != 0);
        });
        var missing = nonempty.filter(function (subproject) {
          return (subproject.ntestfail == 0 && subproject.ntestnotrun == 0 && subproject.ntestpass == 0);
        });
        present = present.concat(missing);
        break;
    }

    return present.concat(empty);
  };
});


CDash.filter('ctestNonXmlCharEscape', function() {
  return function(input) {
    var pattern = /\[NON-XML-CHAR-0x1B\]/g;
    return input.replace(pattern, '\x1B');
  };
})
.filter('terminalColors', function() {
  return function(input, htmlEscape) {
    var ansiUp = new AnsiUp;
    if (htmlEscape !== undefined) {
      ansiUp.escape_for_html = htmlEscape;
    }
    return ansiUp.ansi_to_html(input);
  };
})
.filter('trustAsHtml', ['$sce', function($sce) {
  return function(input) {
    return $sce.trustAsHtml(input);
  };
}]);

// Handle intra-page links.
CDash.service('anchors', function ($anchorScroll, $location, $timeout) {
  this.jumpToAnchor = function(elementId) {
    $timeout(function() {
      $location.hash(elementId);
      $anchorScroll();
    });
  };
});

// Encapsulate common code involved in loading our page data from the API.
CDash.factory('apiLoader', function ($http, $rootScope, $window, renderTimer) {
  var loadPageData = function(controllerScope, endpoint) {
    controllerScope.loading = true;

    $http({
      url: endpoint,
      method: 'GET',
      params: $rootScope.queryString
    }).then(function success(s) {
      var cdash = s.data;

      // Check if we should display filters.
      if (cdash.filterdata && cdash.filterdata.showfilters == 1) {
        controllerScope.showfilters = true;
      }

      // Time how long it takes to render the page.
      renderTimer.initialRender(controllerScope, cdash);

      // Set title in root scope so the head controller can see it.
      $rootScope['title'] = cdash.title;

      // Save a copy of where we loaded this data from.
      // This is used to link the user to a copy of the data in JSON format.
      controllerScope.cdash.endpoint = endpoint + $window.location.search;

      // Do any subsequent setup required for this particular controller.
      if (typeof controllerScope.finishSetup === "function") {
        controllerScope.finishSetup();
      }
    }, function error(e) {
      controllerScope.cdash = e.data;
    }).finally(function() {
      controllerScope.loading = false;
    });
  };
  return {
    loadPageData: loadPageData
  };
});

// How to compare different types of data.
angular
  .module('CDash')
  .factory('comparators', comparators);

function comparators() {
  return {
    getComparators : function() {
      return {
        array:
          [
            {
              pos: 1,
              symbol: "in",
              text: "contains"
            },
            {
              pos: 2,
              symbol: "not in",
              text: "does not contain"
            }
          ],
        bool:
          [
            {
              pos: 1,
              symbol: "==",
              text: "is"
            },
            {
              pos: 2,
              symbol: "!=",
              text: "is not"
            }
          ],
        number:
          [
            {
              pos: 1,
              symbol: "<",
              text: "is less than"
            },
            {
              pos: 2,
              symbol: ">",
              text: "is greater than"
            },
            {
              pos: 3,
              symbol: "==",
              text: "equals"
            }
          ]
      };
    }
  }
}

CDash.factory('filters', function () {
  var filters = {};

  filters.toggle = function(show) {
    var str = new String(window.location);
    var idx = str.indexOf("&showfilters=", 0);
    if (idx > 0) {
      if (show) {
        window.location.href = str.replace("&showfilters=0", "&showfilters=1");
      } else {
        window.location.href = str.replace("&showfilters=1", "&showfilters=0");
      }
    }
  }

  filters.getString = function() {
    var str = new String(window.location);
    var idx = str.indexOf("&filtercount=", 0);
    if (idx > 0) {
      return str.substr(idx);
    }
    else {
      return "";
    }
  }

  filters.getLabelString = function(filterdata) {
    if ( filterdata == undefined ) {
      return "";
    }

    var s = "&showfilters=1";
    var n = 0;
    for (var i = 1; i <= filterdata.filters.length; i++) {
      var field = filterdata.filters[i-1].field;
      if (field == 'label') {
        n = n + 1;
        s = s + "&field" + i + "=" + escape(field);
        s = s + "&compare" + i + "=" + escape(filterdata.filters[i-1].compare);
        s = s + "&value" + i + "=" + escape(filterdata.filters[i-1].value);
      }
    }

    if (n > 1) {
      s = "&filtercombine=" + filterdata.filtercombine + s;
    }

    if (n > 0) {
      return "&filtercount=" + n + s;
    }
    else {
      return "";
    }
  }

  return filters;
});

CDash.factory('modalSvc', function modalSvc ($uibModal) {
  const showModal = function(modelId, okFn, template, parent_scope, size, success, error) {
    parent_scope = typeof parent_scope !== 'undefined' ? parent_scope : null;
    size = typeof size !== 'undefined' ? size : 'sm';
    $modal = $uibModal.open({
      animation: true,
      backdrop: true,
      controller: function () {
        var $ctrl = this;
        $ctrl.ok = function() {
          okFn(modelId);
          $modal.close();
        };
        $ctrl.cancel = function () {
          $modal.close();
        }
      },
      controllerAs: '$ctrl',
      size: size,
      scope: parent_scope,
      templateUrl: template,
    });

    // some clarification...
    // success is the result of a successful button click (e.g. $ctrl.ok,
    // $ctrl.cancel)
    success = angular.isFunction(success)? success : function () {};

    // error is triggered as the result of a backdrop click thus it is
    // not really an error, but for convention's sake sticking with error
    error = angular.isFunction(error) ? error : function () {};

    // prevent console from complaining about unhandled backdrop click
    $modal.result.then(success, error);

    return $modal;
  };

  return {
    showModal: showModal,
  };
});

// Sort by multiple columns at once.
CDash.factory('multisort', function () {
  return {
    updateOrderByFields: function(obj, field, $event) {
      // Note that by default we sort in descending order.
      // This is accomplished by prepending the field with '-'.

      var idx = obj.orderByFields.indexOf('-' + field);
      if ($event.shiftKey) {
        // When shift is held down we append this field to the list of sorting
        // criteria.
        if (idx != -1) {
          // Reverse sort for this field because it was already in the list.
          obj.orderByFields[idx] = field;
        } else {
          var idx2 = obj.orderByFields.indexOf(field);
          if (idx2 != -1) {
            // If field is in the list replace it with -field.
            obj.orderByFields[idx2] = '-' + field;
          } else {
            // Otherwise just append -field to the end of the list.
            obj.orderByFields.push('-' + field);
          }
        }
      } else {
        // Shift wasn't held down so this field is the only criterion that we
        // will use for sorting.
        if (idx != -1) {
          obj.orderByFields = [field];
        } else {
          obj.orderByFields = ['-' + field];
        }
      }
    }
  };
});

// Time how long the initial render takes and add this to the value
// shown at the bottom of the page.
CDash.factory('renderTimer', function ($timeout) {
  var initialRender = function(controllerScope, cdash) {
    // Redirect if the API told us to.
    if ('redirect' in cdash) {
      window.location = cdash.redirect;
      return;
    }

    if (!"generationtime" in cdash) {
      return;
    }
    var start = new Date();

    // This is when the initial page render happens.
    controllerScope.cdash = cdash;

    $timeout(function() {
      var renderTime = +((new Date() - start) / 1000);
      controllerScope.cdash.generationtime = (renderTime + cdash.generationtime).toFixed(2);
    }, 0, true, controllerScope, cdash);
  };
  return {
    initialRender: initialRender
  };
});

CDash.controller('BuildPropertiesController',
  function BuildPropertiesController($filter, $http, $scope, apiLoader, comparators, modalSvc, multisort) {
    apiLoader.loadPageData($scope, 'api/v1/buildProperties.php');
    $scope.finishSetup = function() {
      if ($scope.cdash.builds.length < 1) {
        return;
      }

      $scope.cdash.showDefects = false;
      $scope.cdash.defectsLoaded = false;

      $scope.cdash.selections = [];
      $scope.addSelection();

      // Isolate property keys for auto-completion.
      $scope.cdash.propertykeys = Object.keys($scope.cdash.properties);

      // A different set of comparators for each possible type of build property.
      $scope.comparators = comparators.getComparators();

      // Pagination settings for defects table.
      $scope.pagination = [];
      $scope.pagination.filteredTests = [];
      $scope.pagination.currentPage = 1;
      $scope.pagination.maxSize = 5;
      var num_per_page_cookie = $.cookie('buildProperties_num_per_page');
      if(num_per_page_cookie) {
        $scope.pagination.numPerPage = parseInt(num_per_page_cookie);
      } else {
        $scope.pagination.numPerPage = 10;
      }

      // Sorting for defects table.
      var sort_cookie_value = $.cookie('cdash_buildProperties_sort');
      if(sort_cookie_value) {
        $scope.orderByFields = sort_cookie_value.split(",");
      } else {
        $scope.orderByFields = ['-builds.length'];
      }

      $scope.chart_data = [];
      $scope.groups = [];
      $scope.addGroup('All', $scope.cdash.builds);
      $scope.computeChartData();

      // Initial render of chart.
      nv.addGraph(function() {
        $scope.chart = nv.models.multiBarChart()
          .duration(350)
          .rotateLabels(0)      //Angle to rotate x-axis labels.
          .showControls(true)   //Allow user to switch between 'Grouped' and 'Stacked' mode.
          .groupSpacing(0.1)    //Distance between each group of bars.
        ;

        $scope.chart.xAxis.tickFormat(function(d) {
          if ($scope.groups[d] !== undefined) {
            return $scope.groups[d].keyword;
          } else {
            return '';
          }
        });
        $scope.chart.yAxis.tickFormat(d3.format(',f'));
        $scope.chart.yAxis.axisLabel("Number of Builds");


        $scope.chart_selection = d3.select('#chart svg') .datum($scope.chart_data);
        $scope.chart_selection.call($scope.chart);

        $scope.chart.update();
        nv.utils.windowResize($scope.chart.update);
        return $scope.chart;
      });
    };

    $scope.addGroup = function(groupname, builds) {
      var pos = $scope.groups.length;
      var group = {
        keyword: groupname,
        position: pos,
        builds: builds
      };
      $scope.groups.push(group);
    };

    $scope.computeChartData = function() {
      $scope.chart_data = [];

      // Count how many builds are in each group.
      var group_totals = [];
      for (var i = 0; i < $scope.groups.length; ++i) {
        group_totals.push({
          x: $scope.groups[i].position,
          y: $scope.groups[i].builds.length
        });
      }

      // Count how many builds have each type of defect for each group.
      for (var i = 0; i < $scope.cdash.defecttypes.length; ++i) {
        var defect_type = $scope.cdash.defecttypes[i];
        if (!defect_type.selected) {
          continue;
        }
        var defect_values = [];
        for (var j = 0; j < $scope.groups.length; ++j) {
          var group = $scope.groups[j], defective_builds = 0;
          for (var k = 0; k < group.builds.length; ++k) {
            var build = group.builds[k];
            defective_builds += build[defect_type.name] > 0 ? 1 : 0;
          }
          defect_values.push({
            x: group.position,
            y: defective_builds
          });
        }
        $scope.chart_data.push({
          key: defect_type.prettyname,
          values: defect_values
        });
      }

      $scope.chart_data.push({
        key: "Total",
        values: group_totals
      });
    };

    $scope.updateSelection = function() {
      var uri = '//' + location.host + location.pathname + '?project=' + $scope.cdash.projectname_encoded;
      // Include date range from time chart.
      if ($scope.cdash.begin_date == $scope.cdash.end_date) {
        uri += '&date=' + $scope.cdash.begin_date;
      } else {
        uri += '&begin=' + $scope.cdash.begin_date + '&end=' + $scope.cdash.end_date;
      }

      // Get selected defects.
      var defect_types = [];
      for (var i = 0; i < $scope.cdash.defecttypes.length; ++i) {
        var defect_type = $scope.cdash.defecttypes[i];
        if (defect_type.selected) {
          defect_types.push(defect_type.name);
        }
      }
      if (defect_types.length > 0) {
        uri += '&defects=' + defect_types.join();
      }

      window.location = uri;
    };

    // Split the "All" / "Remainder" group when adding a new selection.
    $scope.split = function(groupName, filterExpression) {
      if ($scope.groups.length == 1) {
        // First split.  Remove the default 'All' group.
        $scope.groups = [];
      } else {
        // Remove the 'Remainder' group.
        var index = -1;
        for (var i = 0, len = $scope.groups.length; i < len; i++) {
          if ($scope.groups[i].keyword === 'Remainder') {
            index = i;
            break;
          }
        }
        if (index > -1) {
          $scope.groups.splice(index, 1);
        }
      }

      // Find the builds that match our expression.
      var matchingBuilds = $filter('filter')($scope.cdash.builds, filterExpression);
      $scope.addGroup(groupName, matchingBuilds);

      // (Re-)create the 'Remainder' group.
      var remainingBuilds = $filter('filter')($scope.cdash.builds, function(value, index, array) {
        var keep_this_build = true;
        for (var i = 0; i < $scope.groups.length; ++i) {
          var group = $scope.groups[i];
          for (var j = 0; j < group.builds.length; ++j) {
            var build = group.builds[j];
            if (value.id == build.id) {
              keep_this_build = false;
              break;
            }
          }
          if (!keep_this_build) {
            break;
          }
        }
        return keep_this_build;
      });
      $scope.addGroup('Remainder', remainingBuilds);

      $scope.computeChartData();
      $scope.rerenderChart();
    };

    // Remove a group and put its builds back in the "All" / "Remainder" group.
    $scope.unsplit = function(groupName) {
      // Find the group to remove.
      var idx_to_remove = -1;
      for (var i = 0, len = $scope.groups.length; i < len; i++) {
        if ($scope.groups[i].keyword === groupName) {
          idx_to_remove = i;
          break;
        }
      }
      if (idx_to_remove === -1) {
        return;
      }
      var groupToRemove = $scope.groups[idx_to_remove];

      // Find the group named "Remainder".
      var idx_remain = -1;
      for (var i = 0, len = $scope.groups.length; i < len; i++) {
        if ($scope.groups[i].keyword === "Remainder") {
          idx_remain = i;
          break;
        }
      }
      if (idx_remain === -1) {
        return;
      }

      // Find any builds in the group to be removed that do not belong
      // anywhere else.  Add those back into the "Remainder" group.
      var buildids_to_move = [];
      for (var i = 0, len1 = groupToRemove.builds.length; i < len1; i++) {
        var build = groupToRemove.builds[i], move_this_build = true;
        for (var j = 0, len2 = $scope.groups.length; j < len2; j++) {
          var group = $scope.groups[j];
          if (j === idx_to_remove || group.keyword === "Remainder") {
            continue;
          }
          for (var k = 0, len3 = group.builds.length; k < len3; k++) {
            if (group.builds[k].id === build.id) {
              move_this_build = false;
              break;
            }
          }
          if (!move_this_build) {
            break;
          }
        }
        if (move_this_build) {
          buildids_to_move.push(groupToRemove.builds[i].id);
        }
      }

      // Move the appropriate builds back to the "Remainder" group.
      var filterExpression = function(value, index, array) {
        if (buildids_to_move.indexOf(value.id) === -1) {
          return false;
        }
        return true;
      };
      var matchingBuilds = $filter('filter')($scope.cdash.builds, filterExpression);
      $scope.groups[idx_remain].builds = $scope.groups[idx_remain].builds.concat(matchingBuilds);

      // Now we can remove the group.
      $scope.groups.splice(idx_to_remove, 1);

      // Update positions of surviving groups.
      for (var i = 0, len = $scope.groups.length; i < len; i++) {
        $scope.groups[i].position = i;
      }

      if ($scope.groups.length == 1) {
        // If we're back down to one group, rename it from "Remainder" to "All".
        $scope.groups[0].keyword = "All";
      }

      // Redraw the chart.
      $scope.computeChartData();
      $scope.rerenderChart();
    };

    $scope.rerenderChart = function() {
      $scope.chart_selection.datum($scope.chart_data).transition().duration(500).call($scope.chart);
      nv.utils.windowResize($scope.chart.update);
    };


    $scope.addSelection = function() {
      var selection = [
        {
          'name': '',
          'comparator': '',
          'comparators': [],
          'property': '',
          'applied': false
        }
      ];
      $scope.cdash.selections.push(selection);
    };

    $scope.removeSelection = function(selection) {
      var index = $scope.cdash.selections.indexOf(selection);
      if (index > -1) {
        $scope.cdash.selections.splice(index, 1);
        $scope.unsplit(selection.name);
      }
    };

    $scope.applySelection = function(selection) {
      var user_clause = selection.property + " " + selection.comparator.symbol + " " + selection.value;
      var actual_code = 'value.properties.' + user_clause;

      var filterExpression = function(value, index, array) {
        try {
          var b = eval(actual_code);
        } catch (err) {
          selection.error = err.message;
        }
        if (b) {
          return true;
        }
        return false;
      };

      selection.applied = true;
      $scope.split(selection.name, filterExpression);
      $scope.addSelection();
    };

    $scope.updateComparators = function(selection) {
      var idx = $scope.cdash.propertykeys.indexOf(selection.property);
      if (idx != -1) {
        var type = $scope.cdash.properties[selection.property].type;
        selection.comparators = $scope.comparators[type];
      }
    };

    $scope.showModal = function(defect) {
      $scope.cdash.currentDefect = defect;
      modalSvc.showModal(null, function(){}, 'modal-template', $scope, 'lg');
    };

    $scope.toggleDefects = function() {
      if (!$scope.cdash.defectsLoaded) {
        $scope.loadDefects();
      } else {
        $scope.cdash.showDefects = !$scope.cdash.showDefects;
      }
    };

    $scope.loadDefects = function() {
      $scope.cdash.loadingDefects = true;

      var buildids = [];
      for (var i = 0; i < $scope.cdash.builds.length ; ++i) {
        buildids.push($scope.cdash.builds[i].id);
      }

      var defect_types = [];
      for (var i = 0; i < $scope.cdash.defecttypes.length; ++i) {
        var defect_type = $scope.cdash.defecttypes[i];
        if (defect_type.selected) {
          defect_types.push(defect_type.name);
        }
      }

      // Query the API to get the types of defects suffered by these builds.
      var parameters = {
        "buildid[]": buildids,
        "defect[]": defect_types
      };
      $scope.cdash.defectsError = '';
      $http({
        url: 'api/v1/buildProperties.php',
        method: 'GET',
        params: parameters
      }).then(function success(s) {
        $scope.cdash.defects = s.data.defects;
        for (var i = 0; i < $scope.cdash.defects.length; ++i) {
          $scope.cdash.defects[i].classifiersLoaded = false;
          $scope.cdash.defects[i].loadingClassifiers = false;
          $scope.cdash.defects[i].showClassifiers = false;
        }
        $scope.cdash.defects = $filter('orderBy')($scope.cdash.defects, $scope.orderByFields);
        $scope.cdash.defectsLoaded = true;
        $scope.cdash.showDefects = true;
        $scope.pageChanged();
      }, function error(e) {
        $scope.cdash.defectsError = e.data;
      }).finally(function() {
        $scope.cdash.loadingDefects = false;
      });
    };

    $scope.toggleClassifiers = function(defect) {
      if (!defect.classifiersLoaded) {
        $scope.computeClassifiers(defect);
      }
      defect.showClassifiers = !defect.showClassifiers;
    };

    $scope.computeClassifiers = function(defect) {
      defect.loadingClassifiers = true;
      // Mark each build as passing or failing.
      for (var i = 0; i < $scope.cdash.builds.length; ++i) {
        if (defect.builds.indexOf($scope.cdash.builds[i].id) === -1) {
          $scope.cdash.builds[i].success = true;
        } else {
          $scope.cdash.builds[i].success = false;
        }
      }
      // Send the builds back to our API, which will figure out what properties are
      // most informative in distinguishing between passing & failing.
      var parameters = {
        "builds[]": $scope.cdash.builds
      };
      $http({
        url: 'api/v1/computeClassifier.php',
        method: 'GET',
        params: parameters
      }).then(function success(s) {
        defect.classifiers = s.data;
        defect.classifiersLoaded = true;
      }, function error(e) {
        $scope.cdash.warning = e.data;
      }).finally(function() {
        defect.loadingClassifiers = false;
      });
    };

    $scope.pageChanged = function() {
      var begin = (($scope.pagination.currentPage - 1) * $scope.pagination.numPerPage)
      , end = begin + $scope.pagination.numPerPage;
      if (end > 0) {
        $scope.pagination.filteredDefects = $scope.cdash.defects.slice(begin, end);
      } else {
        $scope.pagination.filteredDefects = $scope.cdash.defects;
      }
    };

    $scope.numDefectsPerPageChanged = function() {
      $.cookie("buildProperties_num_per_page", $scope.pagination.numPerPage, { expires: 365 });
      $scope.pageChanged();
    };

    $scope.updateOrderByFields = function(field, $event) {
      multisort.updateOrderByFields($scope, field, $event);
      $scope.cdash.defects = $filter('orderBy')($scope.cdash.defects, $scope.orderByFields);
      $scope.pageChanged();
      $.cookie('cdash_buildProperties_sort', $scope.orderByFields);
    };
});

CDash.controller('CompareCoverageController',
  function CompareCoverageController($scope, $rootScope, apiLoader, filters, multisort) {
    // Hide filters by default.
    $scope.showfilters = false;

    // Check for filters.
    $rootScope.queryString['filterstring'] = filters.getString();

    $scope.sortCoverage = { orderByFields: [] };

    apiLoader.loadPageData($scope, 'api/v1/compareCoverage.php');

    $scope.showfilters_toggle = function() {
      $scope.showfilters = !$scope.showfilters;
      filters.toggle($scope.showfilters);
    };

    $scope.updateOrderByFields = function(obj, field, $event) {
      multisort.updateOrderByFields(obj, field, $event);
    };
});

CDash.controller('CreateProjectController',
  function CreateProjectController($scope, $http, $location, $timeout, apiLoader, Upload) {
    apiLoader.loadPageData($scope, 'api/v1/createProject.php');

    $scope.finishSetup = function() {
      $scope.cdash.changesmade = false;
      var activeTab = 1;
      var disableTabs = false;

      // Go to a specific tab if one was specified.
      var hash = $location.hash();
      if (hash.startsWith('tab')) {
        var whichTab = hash.match(/\d+/);
        if (whichTab) {
          activeTab = whichTab;
        }
      }

      if ($scope.cdash.edit == 0) {
        disableTabs = true;
        $scope.cdash.submitdisabled = true;
      }

      $scope.cdash.tabs = [
        {
          'disabled': false,
          'active': activeTab == 1
        },
        {
          'disabled': disableTabs,
          'active': activeTab == 2
        },
        {
          'disabled': disableTabs,
          'active': activeTab == 3
        },
        {
          'disabled': disableTabs,
          'active': activeTab == 4
        },
        {
          'disabled': disableTabs,
          'active': activeTab == 5
        },
        {
          'disabled': disableTabs,
          'active': activeTab == 6
        }
      ];

      if ($scope.cdash.edit == 1) {
        $scope.cdash.tabs.push({
          'disabled': false,
          'active': activeTab == 7
        });
        $scope.cdash.tabs.push({
          'disabled': false,
          'active': activeTab == 8
        });
      }

      // Example URLs to create a new issue on a supported bug tracking system.
      $scope.cdash.bugtrackerexamples = {
        Buganizer: '<bug-url>/new?component=###&template=###',
        GitHub: 'https://github.com/:owner/:repo/issues/new?',
        JIRA: '<bug-url>/secure/CreateIssueDetails!init.jspa?pid=###&issuetype=#'
      };
      $scope.cdash.bugtrackertypes = Object.keys($scope.cdash.bugtrackerexamples);
      if ($scope.cdash.project.BugTrackerType && $scope.cdash.project.BugTrackerNewIssueUrl) {
        $scope.cdash.issuecreation = true;
      } else {
        $scope.cdash.issuecreation = false;
      }
    };

    $scope.showHelp = function(id_div) {
      $(".tab_help").html($("#"+id_div).html()).show();
    };

    $scope.clearHelp = function() {
      $('.tab_help').html('');
    };

    $scope.nextTab = function(idx) {
      if(idx == 0 && ($scope.cdash.project.Name === undefined || $scope.cdash.project.Name == '')) {
        alert('please specify a name for the project.');
        return false;
      }
      $scope.gotoTab(idx + 1);
      if(idx == 4) {
        $scope.cdash.submitdisabled = false;
      }
    };

    $scope.previousTab = function(idx) {
      $scope.gotoTab(idx - 1);
    };

    $scope.gotoTab = function(idx) {
      $scope.clearHelp();
      for (var i = 0; i < $scope.cdash.tabs.length; i++) {
        $scope.cdash.tabs[i].active = false;
      }
      $scope.cdash.tabs[idx].disabled = false;
      $scope.cdash.tabs[idx].active = true;
      $scope.setTab(idx);
    };

    $scope.setTab = function(idx) {
      $location.hash("tab" + idx);
    };

    $scope.createProject = function() {
      var parameters = {
        Submit: true,
        project: $scope.cdash.project
      };
      $http.post('api/v1/project.php', parameters)
      .then(function success(s) {
        var cdash = s.data;
        if (cdash.projectcreated && cdash.project) {
          $scope.cdash.projectcreated = cdash.projectcreated;
          $scope.cdash.project = cdash.project;
          $scope.setLogo();
        }
      }, function error(e) {
        $scope.cdash.error = e.data.error;
      });
    };

    $scope.updateProject = function() {
      var parameters = {
        Update: true,
        project: $scope.cdash.project
      };
      $http.post('api/v1/project.php', parameters)
      .then(function success(s) {
        var cdash = s.data;
        if (cdash.projectupdated && cdash.project) {
          $scope.cdash.changesmade = false;
          $scope.cdash.projectupdated = true;
          $scope.cdash.project = cdash.project;
          $scope.setLogo();
          $scope.startFade = false;
          $timeout(function() {
            $scope.cdash.projectupdated = false;
            $scope.startFade = true;
          }, 2000);
        }
      }, function error(e) {
        $scope.cdash.error = e.data.error;
      });
    };

    $scope.setLogo = function() {
      if ($scope.cdash.logoFile) {
        Upload.upload({
          url: 'api/v1/project.php',
          data: {
            project: $scope.cdash.project,
            logo: $scope.cdash.logoFile
          }
        }).then(function (resp) {
          if (resp.data.imageid > 0) {
            $scope.cdash.logoFile = null;
            // Use a decache to force the logo to refresh even if the imageid didn't change.
            var imageid = resp.data.imageid + "&decache=" + new Date().getTime();
            $scope.cdash.project.ImageId = imageid;
            $scope.cdash.logoid = imageid;
          }
        });
      }
    };

    $scope.deleteProject = function() {
      if (window.confirm("Are you sure you want to delete this project?")) {
        var parameters = { project: $scope.cdash.project };
        $http({
          url: 'api/v1/project.php',
          method: 'DELETE',
          params: parameters
        }).then(function success() {
          // Redirect to user.php
          window.location = 'user.php';
        });
      }
    };

    $scope.changeViewerType = function() {
      if (!$scope.cdash.selectedViewer) {
        return;
      }
      $scope.cdash.project.CvsViewerType = $scope.cdash.selectedViewer.value;
      if (!$scope.cdash.project.CvsUrl) {
        return;
      }
      var parameters = {
        method: 'repository',
        task: 'exampleurl',
        url: $scope.cdash.project.CvsUrl,
        type: $scope.cdash.selectedViewer.value
      };
      $http({
        url: 'api/v1/index_old.php',
        method: 'GET',
        params: parameters
      }).then(function success(s) {
        $scope.cdash.repositoryurlexample = s.data;
      });
    };

    $scope.addRepository = function() {
      // Add another repository form.
      $scope.cdash.project.repositories.push({
        url: '',
        branch: '',
        username: '',
        password: ''
      });
    };

    $scope.addBlockedBuild = function(blockedbuild) {
      var parameters = {
        project: $scope.cdash.project,
        AddBlockedBuild: blockedbuild
      };
      $http.post('api/v1/project.php', parameters)
      .then(function success(s) {
        var cdash = s.data;
        if (cdash.blockedid > 0) {
          blockedbuild.id = cdash.blockedid;
          $scope.cdash.project.blockedbuilds.push(blockedbuild);
          $scope.cdash.buildblocked = true;
          $scope.startFade = false;
          $timeout(function() {
            $scope.cdash.buildblocked = false;
            $scope.startFade = true;
            }, 2000);
        }
      }, function error(e) {
        $scope.cdash.error = e.data.error;
      });
    };

    $scope.removeBlockedBuild = function(blockedbuild) {
      var parameters = {
        project: $scope.cdash.project,
        RemoveBlockedBuild: blockedbuild
      };
      $http.post('api/v1/project.php', parameters)
      .then(function success(s) {
        var cdash = s.data;
        // Find and remove this build.
        var index = -1;
        for(var i = 0, len = $scope.cdash.project.blockedbuilds.length; i < len; i++) {
          if ($scope.cdash.project.blockedbuilds[i].id === blockedbuild.id) {
            index = i;
            break;
          }
        }
        if (index > -1) {
          $scope.cdash.project.blockedbuilds.splice(index, 1);
        }
      }, function error(e) {
        $scope.cdash.error = e.data.error;
      });
    };

    $scope.changeTrackerType = function() {
      if (!$scope.cdash.project.BugTrackerType) {
        return;
      }
      if (!$scope.cdash.project.BugTrackerType in $scope.cdash.bugtrackerexamples) {
        $scope.cdash.newissuehelp = '';
      } else {
        $scope.cdash.newissuehelp = $scope.cdash.bugtrackerexamples[$scope.cdash.project.BugTrackerType];
      }
    };

});

angular
    .module('CDash')
    .controller('FiltersController', FiltersController);

function FiltersController($scope, $rootScope, $http, $timeout) {

  // The different type of data filters that we support.
  $scope.filterdefinitions = {
    "buildduration": {
      "text": "Build Duration",
      "type": "number",
      "defaultvalue": 0
    },
    "builderrors": {
      "text": "Build Errors",
      "type": "number",
      "defaultvalue": 0
    },
    "buildgenerator": {
      "text": "Submission Client",
      "type": "string",
      "defaultvalue": "2.8"
    },
    "buildname": {
      "text": "Build Name",
      "type": "string",
      "defaultvalue": ""
    },
    "buildstamp": {
      "text": "Build Stamp",
      "type": "string",
      "defaultvalue": ""
    },
    "buildstarttime": {
      "text": "Build Start Time",
      "type": "date",
      "defaultvalue": ""
    },
    "buildtype": {
      "text": "Build Type",
      "type": "string",
      "defaultvalue": "Nightly"
    },
    "buildwarnings": {
      "text": "Build Warnings",
      "type": "number",
      "defaultvalue": 0
    },
    "configureduration": {
      "text": "Configure Duration",
      "type": "number",
      "defaultvalue": 0
    },
    "configureerrors": {
      "text": "Configure Errors",
      "type": "number",
      "defaultvalue": 0
    },
    "configurewarnings": {
      "text": "Configure Warnings",
      "type": "number",
      "defaultvalue": 0
    },
    "coveredlines": {
      "text": "Covered Lines",
      "type": "number",
      "defaultvalue": 0
    },
    "details": {
      "text": "Details",
      "type": "string",
      "defaultvalue": ""
    },
    "expected": {
      "text": "Expected",
      "type": "bool",
      "defaultvalue": ""
    },
    "filename": {
      "text": "Filename",
      "type": "string",
      "defaultvalue": ""
    },
    "groupname": {
      "text": "Group",
      "type": "string",
      "defaultvalue": "Nightly"
    },
    "hascoverage": {
      "text": "Has Coverage",
      "type": "bool",
      "defaultvalue": ""
    },
    "hasctestnotes": {
      "text": "Has CTest Notes",
      "type": "bool",
      "defaultvalue": ""
    },
    "hasdynamicanalysis": {
      "text": "Has Dynamic Analysis",
      "type": "bool",
      "defaultvalue": ""
    },
    "hasusernotes": {
      "text": "Has User Notes",
      "type": "bool",
      "defaultvalue": ""
    },
    "label": {
      "text": "Label",
      "type": "string",
      "defaultvalue": ""
    },
    "priority": {
      "text": "Priority",
      "type": "string",
      "defaultvalue": ""
    },
    "revision": {
      "text": "Revision",
      "type": "string",
      "defaultvalue": ""
    },
    "site": {
      "text": "Site",
      "type": "string",
      "defaultvalue": ""
    },
    "status": {
      "text": "Status",
      "type": "string",
      "defaultvalue": ""
    },
    "subproject": {
      "text": "SubProject",
      "type": "string",
      "defaultvalue": ""
    },
    "subprojects": {
      "text": "SubProjects",
      "type": "list",
      "defaultvalue": "",
      "content": true
    },
    "testname": {
      "text": "Test Name",
      "type": "string",
      "defaultvalue": ""
    },
    "testoutput": {
      "text": "Test Output",
      "type": "search",
      "defaultvalue": "",
      "content": true
    },
    "testsduration": {
      "text": "Tests Duration",
      "type": "number",
      "defaultvalue": 0
    },
    "testsfailed": {
      "text": "Tests Failed",
      "type": "number",
      "defaultvalue": 0
    },
    "testsnotrun": {
      "text": "Tests Not Run",
      "type": "number",
      "defaultvalue": 0
    },
    "testspassed": {
      "text": "Tests Passed",
      "type": "number",
      "defaultvalue": 0
    },
    "testtimestatus": {
      "text": "Tests Timing Failed",
      "type": "number",
      "defaultvalue": 0
    },
    "time": {
      "text": "Time",
      "type": "number",
      "defaultvalue": ""
    },
    "timestatus": {
      "text": "Time Status",
      "type": "string",
      "defaultvalue": ""
    },
    "totallines": {
      "text": "Total Lines",
      "type": "number",
      "defaultvalue": 0
    },
    "uncoveredlines": {
      "text": "Uncovered Lines",
      "type": "number",
      "defaultvalue": 0
    },
    "updateduration": {
      "text": "Update Duration",
      "type": "number",
      "defaultvalue": 0
    },
    "updatedfiles": {
      "text": "Updated Files",
      "type": "number",
      "defaultvalue": 0
    }
  }

  // How our data types can be compared.
  $scope.comparisons = {
    "bool": [
      {"value": 1, text: "is true"},
      {"value": 2, text: "is false"}
     ],
    "date": [
      {"value": 81, text: "is"},
      {"value": 82, text: "is not"},
      {"value": 83, text: "is after"},
      {"value": 84, text: "is before"}
    ],
    "number": [
      {"value": 41, text: "is"},
      {"value": 42, text: "is not"},
      {"value": 43, text: "is greater than"},
      {"value": 44, text: "is less than"}
    ],
    "search": [
      {"value": 94, text: "exclude"},
      {"value": 95, text: "include"},
      {"value": 96, text: "exclude regex"},
      {"value": 97, text: "include regex"},
    ],
    "string": [
      {"value": 63, text: "contains"},
      {"value": 64, text: "does not contain"},
      {"value": 61, text: "is"},
      {"value": 62, text: "is not"},
      {"value": 65, text: "starts with"},
      {"value": 66, text: "ends with"}
    ],
    "list": [
      {"value": 92, text: "exclude"},
      {"value": 93, text: "include"},
    ]
  };

  // Add a new row to our list of filters.
  $scope.addFilter = function(block, index) {
    var previous_filter = block.filters[index-1];
    if (previous_filter.hasOwnProperty('filters')) {
      var filter_to_copy = previous_filter.filters[previous_filter.filters.length - 1];
    } else {
      var filter_to_copy = previous_filter;
    }
    var filter = {
      field: filter_to_copy.field,
      compare: filter_to_copy.compare,
      value: filter_to_copy.value,
    };
    block.filters.splice(index, 0, filter);
  };

  // Remove a filter from our list.
  $scope.removeFilter = function(block, index) {
    block.filters.splice(index-1, 1);
  };

  // Check to see if the type of a filter was changed by the user.
  $scope.changeFilter = function(filter) {
    var type = $scope.filterdefinitions[filter.field].type;
    var comparisons = $scope.comparisons[type];

    // Assign the default comparison value to this filter if its type has changed.
    var found = false;
    for (i in comparisons) {
      if (comparisons[i].value == filter.compare) {
        found = true;
        break;
      }
    }
    if (!found) {
      filter.compare = "0";
    }
  };

  $scope.applyFilters = function() {
    var url = this.createHyperlink();
    window.location.href = url;
  };

  $scope.clearFilters = function() {
    $scope.filterdata.filters = [];
    $scope.applyFilters();
  };

  $scope.displayHyperlink = function() {
    var url = this.createHyperlink();
    $("#div_filtersAsUrl").html("<a href=\"" + url + "\">" + url + "</a>");
  };

  $scope.createHyperlink = function() {
    // Count the number of filters.
    var n = $scope.filterdata.filters.length,
    // Read the current query string parameters.
    params = window.location.search.replace('?', '').split(/[&;]/g);

    // Search for and remove any existing filter/date params.
    var filterParams = ['filtercount', 'filtercombine', 'showfilters', 'field', 'compare', 'value', 'limit', 'date', 'begin', 'end'];
    // Reverse iteration because this is destructive.
    for (var i = params.length; i-- > 0;) {
      for (var j = 0; j < filterParams.length; j++) {
        if (params[i].startsWith(filterParams[j])) {
          params.splice(i, 1);
          break;
        }
      }
    }

    // Reconstruct the URL to include the query string parameters that survived
    // the culling above.
    var s = window.location.origin + window.location.pathname + '?';
    for (var i = 0; i < params.length; i++) {
      s += params[i] + '&';
    }

    // Now add date params.
    if ($scope.cdash.begin && $scope.cdash.end) {
      // Both begin and end were set.
      if ($scope.cdash.begin == $scope.cdash.end) {
        // If they are the same, then convert it to a 'date' param.
        s += 'date=' + $scope.cdash.begin + '&';
      } else {
        // Otherwise construct a URL for a range of date.
        s += 'begin=' + $scope.cdash.begin + '&end=' + $scope.cdash.end + '&';
      }
    } else if ($scope.cdash.begin || $scope.cdash.end) {
      // If only one of begin/end was set, use its value as a 'date' param.
      var date = $scope.cdash.begin ? $scope.cdash.begin : $scope.cdash.end;
      s += 'date=' + date + '&';
    } else if (!$scope.cdash.begin && !$scope.cdash.end) {
      // If both begin and end are explicitly empty then we do not add any
      // date fields to the URL.
    } else if ($scope.cdash.date_set && $scope.cdash.date) {
      // Otherwise include the 'date' param if it was explicitly set (not left blank).
      s += 'date=' + $scope.cdash.date + '&';
    }

    // Now add filter params.
    s = s + "filtercount=" + n;
    s = s + "&showfilters=1";

    l = $("#id_limit").val();
    if (l != 0) {
      s = s + "&limit=" + l;
    }

    if (n > 1) {
      s = s + "&filtercombine=" + $scope.filterdata.filtercombine;
    }

    for (var i = 1; i <= n; i++) {
      if ($scope.filterdata.filters[i-1].hasOwnProperty('filters')) {
        var num_subfilters = $scope.filterdata.filters[i-1].filters.length;
        if (num_subfilters < 1) {
          continue;
        }
        var prefix = "field" + i;
        s = s + "&" + prefix + "=block";
        s = s + "&" + prefix + "count=" + num_subfilters;
        for (var j = 1; j <= num_subfilters ; j++) {
          s = s + "&" + prefix + "field" + j + "=" + encodeURIComponent($scope.filterdata.filters[i-1].filters[j-1].field);
          s = s + "&" + prefix + "compare" + j + "=" + encodeURIComponent($scope.filterdata.filters[i-1].filters[j-1].compare);
          s = s + "&" + prefix + "value" + j + "=" + encodeURIComponent($scope.filterdata.filters[i-1].filters[j-1].value);
        }
      } else {
        s = s + "&field" + i + "=" + encodeURIComponent($scope.filterdata.filters[i-1].field);
        s = s + "&compare" + i + "=" + encodeURIComponent($scope.filterdata.filters[i-1].compare);
        s = s + "&value" + i + "=" + encodeURIComponent($scope.filterdata.filters[i-1].value);
      }
    }

    return s;
  }

  // Add a sub-block of filters to our list.
  $scope.addFilterBlock = function(index) {
    var parent_filter = $scope.filterdata.filters[index-1];
    var or_block = {
      filters: []
    };
    var filter = {
      field: parent_filter.field,
      compare: parent_filter.compare,
      value: parent_filter.value,
    };
    or_block.filters.push(filter);
    $scope.filterdata.filters.splice(index, 0, or_block);
  };

  // Change the value of filterdata.othercombine.
  $scope.updateCombine = function(filterdata) {
    if (filterdata.filtercombine == 'or') {
      filterdata.othercombine = 'and';
    } else {
      filterdata.othercombine = 'or';
    }
  };

  var url = window.location.pathname;
  var filename = url.substring(url.lastIndexOf('/')+1);
  var filename_for_docs = filename;
  if (filename === 'index.php' && 'parentid' in $rootScope.queryString) {
    filename = 'indexchildren.php';
  }
  $rootScope.queryString['page_id'] = filename;
  $rootScope.queryString['showlimit'] = 0;

  $http({
    url: 'api/v1/filterdata.php',
    method: 'GET',
    params: $rootScope.queryString
  }).then(function success(s) {
    var filterdata = s.data;
    filterdata.filters.forEach(function(filter) {
      if (filter.hasOwnProperty('filters')) {
        filter.filters.forEach(function(subfilter) {
          subfilter.compare = subfilter.compare.toString();
        });
      } else if (filter.hasOwnProperty('compare')) {
        filter.compare = filter.compare.toString();
      }
    });

    filterdata.availablenoncontentfilters = filterdata.availablefilters.slice();
    filterdata.availablenoncontentfilters.forEach(function(availablefilter, index, object) {
      var filter_definition = $scope.filterdefinitions[availablefilter];
      if (filter_definition.hasOwnProperty('content') && filter_definition.content) {
        object.splice(index, 1);
      }
    });

    $scope.filterdata = filterdata;
    $scope.cdash.page = filename_for_docs;
    // Set default values for date picker.
    if ($scope.cdash.date_set && $scope.cdash.date) {
      if (!$scope.cdash.begin) {
        $scope.cdash.begin = $scope.cdash.date;
      }
      if (!$scope.cdash.end) {
        $scope.cdash.end = $scope.cdash.date;
      }
    }
  });
}

angular.module('CDash')
       .directive('filterRow', function (VERSION) {
  return {
    templateUrl: 'build/views/partials/filterRow_' + VERSION + '.html'
  };
});

angular.module('CDash')
       .directive('filterButtons', function (VERSION) {
  return {
    templateUrl: 'build/views/partials/filterButtons_' + VERSION + '.html'
  };
});

CDash.controller('HeadController', function HeadController($rootScope, $document) {
  // Adapted from:
  // http://www.quirksmode.org/js/cookies.html
  $rootScope.readCookie = function(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for(var i=0;i < ca.length;i++) {
      var c = ca[i];
      while (c.charAt(0)==' ') c = c.substring(1,c.length);
      if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length,c.length);
    }
    return null;
  };

  // Pick which CSS file to use based on user settings.
  var colorblind = $rootScope.readCookie('colorblind');
  if (colorblind == 1) {
    $rootScope.cssfile = "colorblind";
  } else {
    $rootScope.cssfile = "cdash";
  }

  // Load query string parameters into javascript object.
  $rootScope.queryString = {};
  var match,
      pl     = /\+/g,  // Regex for replacing addition symbol with a space
      search = /([^&=]+)=?([^&]*)/g,
      decode = function (s) { return decodeURIComponent(s.replace(pl, " ")); },
      query  = window.location.search.substring(1);
  while (match = search.exec(query)) {
    $rootScope.queryString[decode(match[1])] = decode(match[2]);
  }

  $rootScope.setupCalendar = function(date) {
    if (date) {
      year = date.substr(0, 4);
      if (date.length == 8) {
        month = date.substr(4, 2);
        day = date.substr(6, 2);
      } else {
        month = date.substr(5, 2);
        day = date.substr(8, 2);
      }
      $('#calendar').datepicker({
        onSelect: $rootScope.calendarSelected,
        defaultDate: new Date(month + '/' + day + '/' + year),
        maxDate: "0D" // restrict to the past
      });
    } else {
      $('#calendar').datepicker({
        onSelect: $rootScope.calendarSelected,
        maxDate: "0D" // restrict to the past
      });
    }
  };

  // Navigate to a different date (from the inline date picker) for the current page.
  $rootScope.calendarSelected = function(dateStr) {
    var dateValue = dateStr.substr(6, 4) + "-" + dateStr.substr(0, 2) + "-" + dateStr.substr(3, 2);
    var uri = window.location.href;
    var dateStr = '&date=' + dateValue;

    // Strip out any previous date/begin/end parameters.
    uri = uri.replace(/(&begin=)[^\&]+/, '');
    uri = uri.replace(/(&end=)[^\&]+/, '');
    uri = uri.replace(/(&date=)[^\&]+/, '');

    var filterIdx = uri.indexOf('&filter');
    if (filterIdx > -1) {
      // Insert the date clause before any filter stuff.
      uri = uri.slice(0, filterIdx) + dateStr + uri.slice(filterIdx);
    } else {
      // No filters, stick the date on the end.
      uri += dateStr;
    }

    window.location = uri;
    $('#calendar').hide();
  };

  $rootScope.toggleCalendar = function() {
    if (!$("#calendar").hasClass("hasDatepicker")) {
      // Setup the calendar the first time it is clicked.
      if ("date" in $rootScope.queryString) {
        $rootScope.setupCalendar($rootScope.queryString.date);
      } else {
        $rootScope.setupCalendar();
      }
    }
    $( "#calendar" ).toggle();
  };

});

CDash.filter("showEmptyBuildsLast", function () {
  // Move missing expected builds and those missing data to the bottom of the table.
  return function (builds, sortField) {
    if (!angular.isArray(builds)) return;

    // Expected builds that haven't submitted yet will appear
    // at the bottom of the table.
    var nonempty = builds.filter(function (build) {
      return !('expectedandmissing' in build);
    });
    var expecteds = builds.filter(function (build) {
      return 'expectedandmissing' in build;
    });

    // Get the primary (first) field that we're sorting by.
    if (angular.isArray(sortField)) {
      if (sortField.length < 1) {
        return nonempty.concat(expecteds);
      }
      sortField = sortField[0];
    }
    if (sortField.charAt(0) == '-') {
      sortField = sortField.substring(1);
    }

    // The only sort fields that could have missing data have
    // a '.' in their name (update.files, compilation.errors, etc.)
    // So if we're not sorting by one of them, we can return early.
    var idx = sortField.indexOf('.');
    if (idx === -1) {
      return nonempty.concat(expecteds);
    }

    // Put builds that don't have any data for our sortField
    // at the bottom of the table, but above the expected-and-missing
    // builds.
    var dataField = sortField.substr(0, idx);
    var present = nonempty.filter(function (build) {
      return dataField in build;
    });
    var missing = nonempty.filter(function (build) {
      return !(dataField in build);
    });

    present = present.concat(missing);
    return present.concat(expecteds);
  };
})


.controller('IndexController', function IndexController($scope, $rootScope, $location, $http, $filter, $timeout, anchors, apiLoader, filters, multisort, modalSvc) {
  // Show spinner while page is loading.
  $scope.loading = true;

  // Hide filters & settings dropdown menu by default.
  $scope.showfilters = false;
  $scope.showsettings = false;

  // Check if we have a cookie for auto-refresh.
  var timer, refresh_cookie = $.cookie('cdash_refresh');
  if(refresh_cookie) {
    $scope.autoRefresh = true;
    timer = $timeout(function () {
      window.location.reload(true);
    }, 5000);
  } else {
    $scope.autoRefresh = false;
  }

  // Hide timeline chart by default. It is conditionally enabled below if
  // we are reviewing results for a single buildgroup.
  $scope.showTimelineChart = false;

  // Check for filters
  $rootScope.queryString['filterstring'] = filters.getString();

  // Check if buildgroup sort order was specified via query string.
  var query_sort_order = [];
  if ('sort' in $rootScope.queryString) {
    query_sort_order = $rootScope.queryString.sort.split(",");
  }

  apiLoader.loadPageData($scope, 'api/v1/index.php');

  $scope.finishSetup = function() {
    // Check for more sorting cookies.  Buildgroup sorting is handled below.
    var sort_order = [];
    var cookie_value = $.cookie('cdash_' + $scope.cdash.projectname + '_coverage_sort');
    if(cookie_value) {
      sort_order = cookie_value.split(",");
    }
    $scope.sortCoverage = { orderByFields: sort_order };

    sort_order = [];
    cookie_value = $.cookie('cdash_' + $scope.cdash.projectname + '_DA_sort');
    if(cookie_value) {
      sort_order = cookie_value.split(",");
    }
    $scope.sortDA = { orderByFields: sort_order };

    sort_order = [];
    cookie_value = $.cookie('cdash_' + $scope.cdash.projectname + '_subproject_sort');
    if(cookie_value) {
      sort_order = cookie_value.split(",");
    }
    $scope.sortSubProjects = { orderByFields: sort_order };

    // Check if we have a cookie for number of rows to display.
    var num_per_page_cookie = $.cookie('num_builds_per_page');

    // Modify some settings if we're viewing the results from a single group.
    if ('buildgroup' in $rootScope.queryString) {
      $scope.showTimelineChart = true;
      $scope.cdash.buildgroup = $rootScope.queryString['buildgroup'];
    }

    for (var i in $scope.cdash.buildgroups) {
      if (!$scope.cdash.buildgroups.hasOwnProperty(i)) {
        continue;
      }

      // Initialize pagination settings.
      $scope.cdash.buildgroups[i].pagination = [];
      $scope.cdash.buildgroups[i].pagination.filteredBuilds = [];
      $scope.cdash.buildgroups[i].pagination.currentPage = 1;
      $scope.cdash.buildgroups[i].pagination.maxSize = 5;
      if(num_per_page_cookie) {
        $scope.cdash.buildgroups[i].pagination.numPerPage = parseInt(num_per_page_cookie);
      } else {
        $scope.cdash.buildgroups[i].pagination.numPerPage = 10;
      }

      // Setup sorting.
      var sorting_set = false;
      if (query_sort_order.length > 0) {
        // Use sort order that was specified via query string.
        $scope.cdash.buildgroups[i].orderByFields = query_sort_order;
        sorting_set = true;
      } else {
        // If sort order wasn't specified via query string, check to see
        // if we have a cookie telling us how to sort this buildgroup.
        var cookie_name = $scope.getCookieName($scope.cdash.buildgroups[i], $scope.cdash.projectname, $scope.cdash.childview);
        var sort_cookie_value = $.cookie(cookie_name);
        if(sort_cookie_value) {
          sort_order = sort_cookie_value.split(",");
          $scope.cdash.buildgroups[i].orderByFields = sort_order;
          sorting_set = true;
        }
      }
      if (!sorting_set) {
        // Default sorting.
        $scope.cdash.buildgroups[i].orderByFields = [];

        // When viewing the children of a single build, show problematic
        // SubProjects sorted oldest to newest.
        if ($scope.cdash.childview == 1) {
          if ($scope.cdash.buildgroups[i].numbuilderror > 0) {
            $scope.cdash.buildgroups[i].orderByFields.push('-compilation.error');
          } else if ($scope.cdash.buildgroups[i].numconfigureerror > 0) {
            $scope.cdash.buildgroups[i].orderByFields.push('-configure.error');
          } if ($scope.cdash.buildgroups[i].numtestfail > 0) {
            $scope.cdash.buildgroups[i].orderByFields.push('-test.fail');
          }
          $scope.cdash.buildgroups[i].orderByFields.push('builddatefull');
        } else if (!('sorttype' in $scope.cdash.buildgroups[i])) {
          // By default, sort by errors & such in the following priority order:
          // configure errors
          if ($scope.cdash.buildgroups[i].numconfigureerror > 0) {
            $scope.cdash.buildgroups[i].orderByFields.push('-configure.error');
          }
          // build errors
          if ($scope.cdash.buildgroups[i].numbuilderror > 0) {
            $scope.cdash.buildgroups[i].orderByFields.push('-compilation.error');
          }
          // tests failed
          if ($scope.cdash.buildgroups[i].numtestfail > 0) {
            $scope.cdash.buildgroups[i].orderByFields.push('-test.fail');
          }
          // tests not run
          if ($scope.cdash.buildgroups[i].numtestnotrun > 0) {
            $scope.cdash.buildgroups[i].orderByFields.push('-test.notrun');
          }
          // configure warnings
          if ($scope.cdash.buildgroups[i].numconfigurewarning > 0) {
            $scope.cdash.buildgroups[i].orderByFields.push('-configure.warning');
          }
          // build warnings
          if ($scope.cdash.buildgroups[i].numbuildwarning > 0) {
            $scope.cdash.buildgroups[i].orderByFields.push('-compilation.warning');
          }
          $scope.cdash.buildgroups[i].orderByFields.push('-builddatefull');
        } else if ($scope.cdash.buildgroups[i]['sorttype'] == 'time') {
          // For continuous integration groups, the most recent builds
          // should be at the top of the list.
          $scope.cdash.buildgroups[i].orderByFields.push('-builddatefull');
        }
      }

      // Initialize paginated results.
      $scope.cdash.buildgroups[i].builds = $filter('orderBy')($scope.cdash.buildgroups[i].builds, $scope.cdash.buildgroups[i].orderByFields);
      $scope.cdash.buildgroups[i].builds = $filter('showEmptyBuildsLast')($scope.cdash.buildgroups[i].builds, $scope.cdash.buildgroups[i].orderByFields);

      // Mark this group has having "normal" builds if it only contains missing & expected builds.
      if (!$scope.cdash.buildgroups[i].hasnormalbuilds && !$scope.cdash.buildgroups[i].hasparentbuilds && $scope.cdash.buildgroups[i].builds.length > 0) {
        $scope.cdash.buildgroups[i].hasnormalbuilds = true;
      }

      $scope.pageChanged($scope.cdash.buildgroups[i]);
    }

    // Check for label filters
    $scope.cdash.extrafilterurl = '';
    if ($scope.cdash.sharelabelfilters) {
      $scope.cdash.extrafilterurl = filters.getLabelString($scope.cdash.filterdata);
    }

    // Read simple/advanced view cookie setting.
    var advanced_cookie = $.cookie('cdash_'+$scope.cdash.projectname+'_advancedview');
    var show_time_columns = 0;
    if(advanced_cookie == 1) {
      $scope.cdash.advancedview = 1;
      if ($scope.cdash.showstarttime) {
        // Don't show time columns for all-at-once subproject builds.
        // This situation is identified by showstarttime being false.
        show_time_columns = 1;
      }
    } else {
      $scope.cdash.advancedview = 0;
    }
    $scope.cdash.showtimecolumns = show_time_columns;

    // Should we show the Test Time column?
    if (!$scope.cdash.showtesttime) {
      $scope.cdash.showtesttime =
        $scope.cdash.advancedview != 0 && $scope.cdash.showstarttime;
    }

    // Determine if we should display any extra columns in the 'Test' section.
    $scope.cdash.extratestcolumns = 0;
    if ($scope.cdash.showtesttime) {
      $scope.cdash.extratestcolumns += 1;
    }
    if ($scope.cdash.advancedview && $scope.cdash.showProcTime) {
      $scope.cdash.extratestcolumns += 1;
    }

    $scope.cdash.numcolumns = 14 + $scope.cdash.extratestcolumns + $scope.cdash.displaylabels;

    var projectid = $scope.cdash.projectid;

    // Expose the jumpToAnchor function to the scope.
    // This allows us to call it from the HTML template.
    $scope.jumpToAnchor = anchors.jumpToAnchor;

    // Honor any intra-page anchor specified in the URI.
    if ($location.hash() != '') {
      anchors.jumpToAnchor($location.hash());
    }

  };


  $scope.toggleAdvancedView = function() {
    if ($scope.cdash.advancedview == 1) {
      $scope.cdash.advancedview = 0;
    } else {
      $scope.cdash.advancedview = 1;
    }
    $.cookie('cdash_'+$scope.cdash.projectname+'_advancedview', $scope.cdash.advancedview);
    window.location.reload(true);
  };


  // The following functions were moved here from cdashBuildGroup.js
  $scope.URLencode = function(sStr) {
    return escape(sStr)
      .replace(/\+/g, '%2B')
      .replace(/\"/g,'%22')
      .replace(/\'/g, '%27');
  };

  $scope.toggleAdminOptions = function(build) {
    if (!("expectedandmissing" in build) &&
        (!("expected" in build) || (build.expected != 0 && build.expected != 1))) {
      build.loading = 1;
      // Determine whether or not this is an expected build.
      $http({
        url: 'api/v1/is_build_expected.php',
        method: 'GET',
        params: { 'buildid': build.id }
      }).then(function success(s) {
        var response = s.data;
        build.loading = 0;
        if ("expected" in response) {
          build.expected = response.expected;
          if ( !("showAdminOptions" in build) || build.showAdminOptions == 0) {
            build.showAdminOptions = 1;
          } else {
            build.showAdminOptions = 0;
          }
        }
      });
    } else {
      if ( !("showAdminOptions" in build) || build.showAdminOptions == 0) {
        build.showAdminOptions = 1;
      } else {
        build.showAdminOptions = 0;
      }
    }
  };

  $scope.toggleBuildProblems = function(build) {
    if (!('hasErrors' in build)) {
      build.loading = 1;
      $http({
        url: 'api/v1/build.php',
        method: 'GET',
        params: {
          'buildid': build.id,
          'getproblems': 1
        }
      }).then(function success(s) {
        var response = s.data;
        build.loading = 0;
        build.showProblems = 1;

        build.hasErrors = response.hasErrors;
        build.failingSince = response.failingSince;
        build.failingDate = response.failingDate;
        build.daysWithErrors = response.daysWithErrors;

        build.hasFailingTests = response.hasFailingTests;
        build.testsFailingSince = response.testsFailingSince;
        build.testsFailingDate = response.testsFailingDate;
        build.daysWithFailingTests = response.daysWithFailingTests;
      });
    } else {
      if (build.showProblems == 0) {
        build.showProblems = 1;
      } else {
        build.showProblems = 0;
      }
    }
  };

  $scope.toggleExpectedInfo = function(build) {
    if (!('lastSubmission' in build)) {
      build.loading = 1;
      $http({
        url: 'api/v1/expectedbuild.php',
        method: 'GET',
        params: {
          'siteid': build.siteid,
          'groupid': build.buildgroupid,
          'name': build.buildname,
          'type': build.buildtype,
          'currenttime': $scope.cdash.unixtimestamp
        }
      }).then(function success(s) {
        var response = s.data;
        build.loading = 0;
        build.showExpectedInfo = 1;
        build.lastSubmission = response.lastSubmission;
        build.lastSubmissionDate = response.lastSubmissionDate;
        build.daysSinceLastBuild = response.daysSinceLastBuild;
      });
    } else {
      if (build.showExpectedInfo == 0) {
        build.showExpectedInfo = 1;
      } else {
        build.showExpectedInfo = 0;
      }
    }
  };

  $scope.showModal = function (buildid) {
    modalSvc.showModal(buildid, $scope.removeBuild, 'modal-template');
  }

  $scope.removeBuild = function(build) {
    var parameters = { buildid: build.id };
      $http({
        url: 'api/v1/build.php',
        method: 'DELETE',
        params: parameters
      }).then(function success() {
        $scope.removeBuildFromScope(build);
    });
  };

  $scope.removeBuildFromScope = function(build) {
    // Find the build to remove in its group.
    var idx1 = -1;
    var idx2 = -1;
    for (var i = 0, len1 = $scope.cdash.buildgroups.length; i < len1; i++) {
      for (var j = 0, len2 = $scope.cdash.buildgroups[i].builds.length; j < len2; j++) {
        if ($scope.cdash.buildgroups[i].builds[j] === build) {
          idx1 = i;
          idx2 = j;
          break;
        }
      }
      if (idx1 != -1) {
        break;
      }
    }
    if (idx1 > -1 && idx2 > -1) {
      // Remove the build from our scope.
      $scope.cdash.buildgroups[idx1].builds.splice(idx2, 1);
      $scope.pageChanged($scope.cdash.buildgroups[idx1]);
    }
  };

  $scope.toggleDone = function(build) {
    var newDoneValue = 1;
    if (build.done == 1) {
      newDoneValue = 0;
    }
    var parameters = {
      buildid: build.id,
      done: newDoneValue
    };
    $http.post('api/v1/build.php', parameters)
    .then(function success() {
      build.done = newDoneValue;
    });
  };

  $scope.toggleExpected = function(build, groupid) {
    if (build.expectedandmissing == 1) {
      // Delete a rule specifying a missing expected build.
      var parameters = {
        siteid: build.siteid,
        groupid: build.buildgroupid,
        name: build.buildname,
        type: build.buildtype
      };
      $http({
        url: 'api/v1/expectedbuild.php',
        method: 'DELETE',
        params: parameters
      }).then(function success() {
        $scope.removeBuildFromScope(build);
      });
    } else {
      var newExpectedValue = 1;
      if (build.expected == 1) {
        newExpectedValue = 0;
      }
      var parameters = {
        buildid: build.id,
        groupid: groupid,
        expected: newExpectedValue
      };
      $http.post('api/v1/build.php', parameters)
      .then(function success() {
        build.expected = newExpectedValue;
      });
    }
  };

  $scope.toggleAutoRefresh = function() {
    var refresh_cookie = $.cookie('cdash_refresh');
    if(refresh_cookie) {
      // Disable autorefresh and remove the cookie.
      $timeout.cancel(timer);
      $scope.autoRefresh = false;
      $.cookie('cdash_refresh', null);
    } else {
      $.cookie('cdash_refresh', 1);
      window.location.reload(true);
    }
  };

  $scope.moveToGroup = function(build, groupid) {
    if (build.expectedandmissing == 1) {
      var parameters = {
        siteid: build.siteid,
        groupid: build.buildgroupid,
        newgroupid: groupid,
        name: build.buildname,
        type: build.buildtype
      };
      $http.post('api/v1/expectedbuild.php', parameters)
      .then(function success() {
        window.location.reload();
      });
    } else {
      var parameters = {
        buildid: build.id,
        newgroupid: groupid,
        expected: build.expected
      };
      $http.post('api/v1/build.php', parameters)
      .then(function success() {
        window.location.reload();
      });
    }
  };

  $scope.colorblind_toggle = function() {
    if ($scope.cdash.filterdata.colorblind) {
      $rootScope.cssfile = "colorblind";
      $.cookie("colorblind", 1, { expires: 365 } );

    } else {
      $rootScope.cssfile = "cdash";
      $.cookie("colorblind", 0, { expires: 365 } );
    }
  };

  $scope.showfilters_toggle = function() {
    $scope.showfilters = !$scope.showfilters;
    filters.toggle($scope.showfilters);
  };

  $scope.numBuildsPerPageChanged = function(obj) {
    $.cookie("num_builds_per_page", obj.pagination.numPerPage, { expires: 365 });
    $scope.pageChanged(obj);
  };

  $scope.pageChanged = function(obj) {
    var begin = ((obj.pagination.currentPage - 1) * obj.pagination.numPerPage)
    , end = begin + obj.pagination.numPerPage;
    if (end > 0) {
      obj.pagination.filteredBuilds = obj.builds.slice(begin, end);
    } else {
      obj.pagination.filteredBuilds = obj.builds;
    }
  };

  $scope.updateOrderByFields = function(obj, field, $event, whichTable) {
    whichTable = whichTable || 'buildgroup';
    var cookie_name = '';
    multisort.updateOrderByFields(obj, field, $event);
    switch (whichTable) {
      case 'buildgroup':
      default:
        cookie_name = $scope.getCookieName(obj, $scope.cdash.projectname, $scope.cdash.childview);
        obj.builds = $filter('orderBy')(obj.builds, obj.orderByFields);
        obj.builds = $filter('showEmptyBuildsLast')(obj.builds, obj.orderByFields);
        $scope.pageChanged(obj);
        break;
      case 'coverage':
        cookie_name = 'cdash_' + $scope.cdash.projectname + '_coverage_sort';
        break;
      case 'DA':
        cookie_name = 'cdash_' + $scope.cdash.projectname + '_DA_sort';
        break;
      case 'subproject':
        cookie_name = 'cdash_' + $scope.cdash.projectname + '_subproject_sort';
        break;
    }
    // Save the new sort order in a cookie.
    $.cookie(cookie_name, obj.orderByFields);
  };

  $scope.normalBuild = function(build) {
    return build.numchildren == 0 || build.expectedandmissing == 1;
  };

  $scope.parentBuild = function(build) {
    return build.numchildren > 0 || build.expectedandmissing == 1;
  };

  $scope.getCookieName = function(buildgroup, projectname, childview) {
    var cookie_name = 'cdash_' + projectname;
    if (childview == 1) {
      cookie_name += '_child_index';
    } else {
      cookie_name += '_index';
    }
    cookie_name += buildgroup.name;
    cookie_name += '_sort';
    return cookie_name;
  };
});

CDash.filter('filter_builds', function() {
  // Filter the builds based on what group they belong to.
  return function(input, group) {
    if (typeof group === 'undefined' || group === null) {
      // No filtering required for default "All" group.
      return input;
    }

    group_id = Number(group.id);
    var output = [];
    for (var i = 0; i < input.length; i++) {
      if (Number(input[i].groupid) === group_id) {
        output.push(input[i]);
      }

    }
    return output;
  };
})

.filter('filter_buildgroups', function() {
  // Filter BuildGroups based on their type
  return function(input, type) {
    if (typeof type === 'undefined' || type === null) {
      return input;
    }
    var output = [];
    for (var i = 0; i < input.length; i++) {
      if (input[i].type === type) {
        output.push(input[i]);
      }
    }
    return output;
  };
})

.controller('ManageBuildGroupController', function ManageBuildGroupController($scope, $http, apiLoader, modalSvc) {
  apiLoader.loadPageData($scope, 'api/v1/manageBuildGroup.php');
  $scope.finishSetup = function() {
    // Sort BuildGroups by position.
    if ($scope.cdash.buildgroups) {
      $scope.cdash.buildgroups.sort(function (a, b) {
        return Number(a.position) - Number(b.position);
      });

      // Update positions when the user stops dragging.
      $scope.sortable = {
        stop: function(e, ui) {
          for (var index in $scope.cdash.buildgroups) {
            $scope.cdash.buildgroups[index].position = index;
          }
        }
      };
    }

    // Define different types of buildgroups.
    $scope.cdash.buildgrouptypes = [
      {name: "Daily", value: "Daily"},
      {name: "Latest", value: "Latest"}
    ];
    $scope.buildType = $scope.cdash.buildgrouptypes[0];
  };

  /** create a new buildgroup */
  $scope.createBuildGroup = function(newBuildGroup, type) {
    var parameters = {
      projectid: $scope.cdash.projectid,
      newbuildgroup: newBuildGroup,
      type: type
    };
    $scope.cdash.buildgroup_error = '';
    $http.post('api/v1/buildgroup.php', parameters)
    .then(function success(s) {
      if (s.status == 201) {
        var buildgroup = s.data;
        $("#buildgroup_created").show();
        $("#buildgroup_created").delay(3000).fadeOut(400);

        // Add this new buildgroup to our scope.
        $scope.cdash.buildgroups.push(buildgroup);

        if (type != "Daily") {
          $scope.cdash.dynamics.push(buildgroup);
        }
      } else if (s.status == 200) {
        // Trying to create a group that already exists.
        $scope.cdash.buildgroup_error = "A group named '" + newBuildGroup + "' already exists for this project.";
      }
    }, function error(e) {
      $scope.cdash.buildgroup_error = e.data.error;
    });
  };

  /** change the order that the buildgroups appear in */
  $scope.updateBuildGroupOrder = function() {
    var newLayout = getSortedElements("#sortable");
    var parameters = {
      projectid: $scope.cdash.projectid,
      newLayout: newLayout
    };
    $http.post('api/v1/buildgroup.php', parameters)
    .then(function success(s) {
      if (s.data.error) {
        $scope.cdash.error = s.data.error;
      }
      else {
        $("#order_updated").show();
        $("#order_updated").delay(3000).fadeOut(400);
      }
    });
  };

  /** modify an existing buildgroup */
  $scope.saveBuildGroup = function(buildgroup, summaryemail) {
    var parameters = {
      projectid: $scope.cdash.projectid,
      buildgroup: buildgroup
    };
    $http({
      url: 'api/v1/buildgroup.php',
      method: 'PUT',
      params: parameters
    }).then(function success(s) {
      if (s.data.error) {
        $scope.cdash.error = s.data.error;
      }
      else {
        $("#buildgroup_updated_" + buildgroup.id).show();
        $("#buildgroup_updated_" + buildgroup.id).delay(3000).fadeOut(400);
      }
    });
  };

  /** delete a buildgroup */
  $scope.deleteBuildGroup = function (buildgroupid) {
    "use strict";
    var parameters = {
      projectid: $scope.cdash.projectid,
      buildgroupid: buildgroupid
    };
    $http({
      url: 'api/v1/buildgroup.php',
      method: 'DELETE',
      params: parameters
    }).then(function success() {
      // Find the index of the group to remove.
      var index = -1;
      for(var i = 0, len = $scope.cdash.buildgroups.length; i < len; i++) {
        if ($scope.cdash.buildgroups[i].id === buildgroupid) {
          index = i;
          break;
        }
      }
      if (index > -1) {
        // Remove the buildgroup from our scope.
        $scope.cdash.buildgroups.splice(index, 1);
      }
    });
  };

  /** displays confirmation modal **/
  $scope.showModal = function(buildgroupid) {
    modalSvc.showModal(buildgroupid, $scope.deleteBuildGroup, 'modal-template');
  };

  /** move builds to a different group */
  $scope.moveBuilds = function(builds, group, expected) {
    var parameters = {
      projectid: $scope.cdash.projectid,
      builds: builds,
      group: group,
      expected: expected
    };
    $http.post('api/v1/buildgroup.php', parameters)
    .then(function success(s) {
      if (s.data.error) {
        $scope.cdash.error = s.data.error;
      }
      else {
        $("#builds_moved").show();
        $("#builds_moved").delay(3000).fadeOut(400);
      }
    });
  };


  /** Add rule for a wildcard BuildGroup */
  $scope.addWildcardRule = function(group, type, nameMatch) {
    var parameters = {
      projectid: $scope.cdash.projectid,
      group: group,
      type: type,
      nameMatch: nameMatch
    };
    $http.post('api/v1/buildgroup.php', parameters)
    .then(function success(s) {
      if (s.data.error) {
        $scope.cdash.error = s.data.error;
      }
      else {
        $("#wildcard_defined").show();
        $("#wildcard_defined").delay(3000).fadeOut(400);
      }
    });
  };


  /** delete a wildcard rule */
  $scope.deleteWildcardRule = function(wildcard) {
    var parameters = {
      projectid: $scope.cdash.projectid,
      wildcard: wildcard
    };
    $http({
      url: 'api/v1/buildgroup.php',
      method: 'DELETE',
      params: parameters
    }).then(function success() {
      // Find the index of the wildcard to remove.
      var index = $scope.cdash.wildcards.indexOf(wildcard);
      if (index > -1) {
        // Remove this wildcard from our scope.
        $scope.cdash.wildcards.splice(index, 1);
      }
    });
  };


  /** add a build row to a dynamic group */
  $scope.addDynamicRow = function(dynamic, buildgroup, site, match) {
    var parameters = {
      projectid: $scope.cdash.projectid,
      dynamic: dynamic,
      buildgroup: buildgroup,
      site: site,
      match: match
    };
    $http.post('api/v1/buildgroup.php', parameters)
    .then(function success(s) {
      if (s.data.error) {
        $scope.cdash.error = s.data.error;
      }
      else {
        // Add this new rule to our scope.
        var idx = $scope.cdash.dynamics.indexOf(dynamic);
        if (idx > -1) {
          if ($scope.cdash.dynamics[idx].rules) {
            $scope.cdash.dynamics[idx].rules.push(s.data);
          } else {
            $scope.cdash.dynamics[idx].rules = [s.data];
          }
        }
        $("#dynamic_defined").show();
        $("#dynamic_defined").delay(3000).fadeOut(400);
      }
    });
  };

  $scope.deleteDynamicRule = function(dynamic, rule) {
    var parameters = {
      projectid: $scope.cdash.projectid,
      dynamic: dynamic,
      rule: rule
    };
    $http({
      url: 'api/v1/buildgroup.php',
      method: 'DELETE',
      params: parameters
    }).then(function success() {
      // Find the index of the dynamic group in question.
      var idx1 = $scope.cdash.dynamics.indexOf(dynamic);
      if (idx1 > -1) {
        // Then find the index of the rule that's being removed.
        var idx2 = $scope.cdash.dynamics[idx1].rules.indexOf(rule);
        if (idx2 > -1) {
          // And remove it from our scope.
          $scope.cdash.dynamics[idx1].rules.splice(idx2, 1);
        }
      }
    });
  };


});

CDash.controller('ManageMeasurementsController',
  function ManageMeasurementsController($http, $scope, apiLoader, modalSvc) {
    apiLoader.loadPageData($scope, 'api/v1/manageMeasurements.php');

    $scope.finishSetup = function() {
      // Mark all measurements as clean (unmodified).
      for (var i = 0, len = $scope.cdash.measurements.length; i < len; i++) {
        $scope.cdash.measurements[i].dirty = false;
      }
      // Create a blank measurement for the user to fill out.
      $scope.newMeasurement();
    };

    $scope.newMeasurement = function() {
      $scope.cdash.newmeasurement = {
        id: -1,
        dirty: false,
        name: '',
        summarypage: 1,
        testpage: 1
      };
    };

    // Save measurements to database.
    $scope.save = function() {
      var measurements_to_save = [];
      // Gather up all the modified measurements.
      for (var i = 0, len = $scope.cdash.measurements.length; i < len; i++) {
        if ($scope.cdash.measurements[i].dirty) {
          measurements_to_save.push($scope.cdash.measurements[i]);
        }
      }

      // Also save the new measurement if the user filled it out.
      if ($scope.cdash.newmeasurement.name != '') {
        measurements_to_save.push($scope.cdash.newmeasurement);
      }

      // Submit the request.
      var parameters = {
        projectid: $scope.cdash.projectid,
        measurements: measurements_to_save
      };
      $http.post('api/v1/manageMeasurements.php', parameters)
      .then(function success(s) {
        $("#save_complete").show();
        $("#save_complete").delay(3000).fadeOut(400);
        if (s.data.id > 0) {
          // Assign an id to the "new" measurement and create a new blank one
          // for the user to fill out.
          $scope.cdash.newmeasurement.id = s.data.id;
          $scope.cdash.measurements.push($scope.cdash.newmeasurement);
          $scope.newMeasurement();
        }
      }, function error(e) {
        $scope.cdash.error = e.data.error;
      });
    };

    // Display confirmation dialog before deleting a measurement.
    $scope.confirmDelete = function(measurement) {
      modalSvc.showModal(measurement.id, $scope.removeMeasurement, 'modal-template');
    }

    // Remove measurement upon confirmation.
    $scope.removeMeasurement = function(id_to_remove) {
      var parameters = {
        projectid: $scope.cdash.projectid,
        id: id_to_remove
      };
      $http({
        url: 'api/v1/manageMeasurements.php',
        method: 'DELETE',
        params: parameters
      }).then(function success() {
        // Find the measurement to remove.
        for (var i = 0, len = $scope.cdash.measurements.length; i < len; i++) {
          if ($scope.cdash.measurements[i].id === id_to_remove) {
            // Remove it from our scope.
            $scope.cdash.measurements.splice(i, 1);
            break;
          }
        }
      });
    };
});

CDash.controller('ManageOverviewController', function ManageOverviewController($scope, $http, apiLoader) {
  apiLoader.loadPageData($scope, 'api/v1/manageOverview.php');
  $scope.finishSetup = function() {
    // Setup sortable elements.
    $scope.buildSortable = {
      stop: function(e, ui) {
        for (var index in $scope.cdash.buildcolumns) {
          $scope.cdash.buildcolumns[index].position = index;
        }
      }
    };
    $scope.staticSortable = {
      stop: function(e, ui) {
        for (var index in $scope.cdash.staticrows) {
          $scope.cdash.staticrows[index].position = index;
        }
      }
    };
  };

  $scope.addBuildColumn = function(column) {
    var index = $scope.cdash.availablegroups.indexOf(column);
    $scope.cdash.availablegroups.splice(index, 1);
    $scope.cdash.buildcolumns.push(column);
  };

  $scope.removeBuildColumn = function(column) {
    var index = $scope.cdash.buildcolumns.indexOf(column);
    $scope.cdash.buildcolumns.splice(index, 1);
    $scope.cdash.availablegroups.push(column);
  };

  $scope.addStaticRow = function(row) {
    var index = $scope.cdash.availablegroups.indexOf(row);
    $scope.cdash.availablegroups.splice(index, 1);
    $scope.cdash.staticrows.push(row);
  };

  $scope.removeStaticRow = function(row) {
    var index = $scope.cdash.staticrows.indexOf(row);
    $scope.cdash.staticrows.splice(index, 1);
    $scope.cdash.availablegroups.push(row);
  };

  $scope.saveLayout = function() {
    // Mark all build and static components as such.
    var buildElements = getSortedElements('#buildSortable');
    for (i = 0; i < buildElements.length; ++i) {
      buildElements[i]['type'] = 'build';
    }
    var staticElements = getSortedElements('#staticSortable');
    for (i = 0; i < staticElements.length; ++i) {
      staticElements[i]['type'] = 'static';
    }

    // Concatenate them together and format as JSON.
    var newLayout = JSON.stringify(buildElements.concat(staticElements));

    $("#loading").attr("src", "img/loading.gif");

    var parameters = {
      projectid: $scope.cdash.projectid,
      saveLayout: newLayout
    };
    $http.post('api/v1/manageOverview.php', parameters)
    .then(function success() {
      $("#loading").attr("src", "img/check.gif");
    });
  };
});

CDash.filter('filter_subproject_groups', function() {
  // Filter the subprojects based on group.
  return function(input, group) {
    if (typeof group === 'undefined' || group === null) {
      // "No filtering required for default "All" group.
      return input;
    }

    group_id = Number(group.id);
    var output = [];
    for (var key in input) {
      if (Number(input[key].group) === group_id) {
        output.push(input[key]);
      }

    }
    return output;
  };
})
.controller('ManageSubProjectController', function ManageSubProjectController($scope, $http, apiLoader) {
  apiLoader.loadPageData($scope, 'api/v1/manageSubProject.php');
  $scope.finishSetup = function() {
    // Sort groups by position.
    if ($scope.cdash.groups) {
      $scope.cdash.groups.sort(function (a, b) {
        return Number(a.position) - Number(b.position);
      });
    }

    // Update positions when the user stops dragging.
    $scope.sortable = {
      stop: function(e, ui) {
        for (var index in $scope.cdash.groups) {
          $scope.cdash.groups[index].position = index;
        }
      }
    };
  };

  $scope.createSubProject = function(newSubProject, groupName) {
    var parameters = {
      projectid: $scope.cdash.projectid,
      newsubproject: newSubProject,
      group: groupName
    };
    $http.post('api/v1/subproject.php', parameters)
    .then(function success(s) {
      var subproj = s.data;
      if (subproj.error) {
        $scope.cdash.error = subproj.error;
      }
      else {
        $("#subproject_created").show();
        $("#subproject_created").delay(3000).fadeOut(400);

        // Add this new subproject to our scope.
        $scope.cdash.subprojects.push(subproj);
      }
    });
  };

  $scope.createGroup = function(newGroup, threshold, isDefault) {
    var parameters = {
      projectid: $scope.cdash.projectid,
      newgroup: newGroup,
      threshold: threshold,
      isdefault: isDefault
    };
    $http.post('api/v1/subproject.php', parameters)
    .then(function success(s) {
      var group = s.data;

      // Update our default group if necessary.
      if (group.is_default) {
        $scope.cdash.default_group_id = group.id;
      }

      // Add this new group to our scope.
      $scope.cdash.groups.push(group);
    });
  };

  $scope.updateGroup = function(group, is_default) {
    var parameters = {
      projectid: $scope.cdash.projectid,
      groupid: group.id,
      name: group.name,
      threshold: group.coverage_threshold,
      is_default: is_default
    };
    $http({
      url: 'api/v1/subproject.php',
      method: 'PUT',
      params: parameters
    }).then(function success(s) {
      if (s.data.error) {
        $scope.cdash.error = s.data.error;
      }
      else {
        $("#group_updated_" + group.id).show();
        $("#group_updated_" + group.id).delay(3000).fadeOut(400);
      }
    });
  };

  $scope.deleteGroup = function(groupId) {
    var parameters = {
      projectid: $scope.cdash.projectid,
      groupid: groupId
    };
    $http({
      url: 'api/v1/subproject.php',
      method: 'DELETE',
      params: parameters
    }).then(function success() {
      // Find the index of the group to remove.
      var index = -1;
      for(var i = 0, len = $scope.cdash.groups.length; i < len; i++) {
        if ($scope.cdash.groups[i].id === groupId) {
          index = i;
          break;
        }
      }
      if (index > -1) {
        // Remove the group from our scope.
        $scope.cdash.groups.splice(index, 1);
      }
    });
  };

  /** Change the order that the groups appear in. */
  $scope.updateGroupOrder = function() {
    var newLayout = getSortedElements("#sortable");
    var parameters = {
      projectid: $scope.cdash.projectid,
      newLayout: newLayout
    };
    $http.post('api/v1/subproject.php', parameters)
    .then(function success(s) {
      if (s.data.error) {
        $scope.cdash.error = s.data.error;
      }
      else {
        $("#order_updated").show();
        $("#order_updated").delay(3000).fadeOut(400);
      }
    });
  };

});

CDash.controller('OverviewController',
  function OverviewController($scope, $location, anchors, apiLoader) {
    apiLoader.loadPageData($scope, 'api/v1/overview.php');
    $scope.finishSetup = function() {
      // Expose the jumpToAnchor function to the scope.
      // This allows us to call it from the HTML template.
      $scope.jumpToAnchor = anchors.jumpToAnchor;

      // Honor any intra-page anchor specified in the URI.
      if ($location.hash() != '') {
        anchors.jumpToAnchor($location.hash());
      }
    };
});

CDash.directive('linechart', function() {
  return {
    restrict: 'E',
    replace: true,
    scope: {
      data: '=data',
      groupname: '=groupname',
      measurementname: '=measurementname',
      project: '=project',
      anchor: '=anchor',
      sort: '=sort'
    },
    template: '<div class="overview-line-chart"/>',
    link: function(scope, element, attrs) {
      if (scope.groupname) {
        var data = JSON.parse(scope.data);
        if (data.length > 0) {
          element[0].id = scope.groupname + "_" + scope.measurementname + "_chart";
          makeLineChart(element[0].id, data, scope.project, scope.anchor, scope.sort);
        }
      }
    }
  };
});

CDash.directive('bulletchart', function() {
  return {
    restrict: 'E',
    replace: true,
    scope: {
      data: '=data',
      categoryname: '=categoryname',
    },
    template: '<div class="overview-bullet-chart"><svg></svg></div>',
    link: function(scope, element, attrs) {
      if (scope.data) {
        element[0].id = scope.data.name_clean + "_" + scope.categoryname + "_bullet";
        var chart_data = JSON.parse(scope.data.chart),
            chart_name = scope.group_name + " " + scope.data.name,
            element_name = "#" + element[0].id + " svg";
        makeBulletChart(
          chart_name,
          element_name,
          scope.data.low,
          scope.data.medium,
          scope.data.satisfactory,
          scope.data.current,
          scope.data.previous,
          25);
      }
    }
  };
});

CDash.controller('QueryTestsController',
  function QueryTestsController($scope, $rootScope, $filter, apiLoader, filters, multisort) {
    $scope.loading = true;

    // Pagination settings.
    $scope.pagination = [];
    $scope.pagination.filteredBuilds = [];
    $scope.pagination.currentPage = 1;
    $scope.pagination.maxSize = 5;

    // Check if we have a cookie for number of tests to display.
    var num_per_page_cookie = $.cookie('queryTests_num_per_page');
    if(num_per_page_cookie) {
      $scope.pagination.numPerPage = parseInt(num_per_page_cookie);
    } else {
      $scope.pagination.numPerPage = 25;
    }

    // Hide filters by default.
    $scope.showfilters = false;

    // Check for filters
    $rootScope.queryString['filterstring'] = filters.getString();

    // Check for sort order cookie.
    var sort_order = [];
    var sort_cookie_value = $.cookie('cdash_query_tests_sort');
    if(sort_cookie_value) {
      sort_order = sort_cookie_value.split(",");
    }
    $scope.orderByFields = sort_order;

    apiLoader.loadPageData($scope, 'api/v1/queryTests.php');
    $scope.finishSetup = function() {
      // Hide test output context by default.
      $scope.cdash.showmatchingoutput = false;

      // Check for label filters
      $scope.cdash.extrafilterurl = filters.getLabelString($scope.cdash.filterdata);
      $scope.cdash.builds = $filter('orderBy')($scope.cdash.builds, $scope.orderByFields);
      $scope.pageChanged();
    };

    $scope.showfilters_toggle = function() {
      $scope.showfilters = !$scope.showfilters;
      filters.toggle($scope.showfilters);
    };


    $scope.pageChanged = function() {
      var begin = (($scope.pagination.currentPage - 1) * $scope.pagination.numPerPage)
      , end = begin + $scope.pagination.numPerPage;
      if (end > 0) {
        $scope.pagination.filteredBuilds = $scope.cdash.builds.slice(begin, end);
      } else {
        $scope.pagination.filteredBuilds = $scope.cdash.builds;
      }
    };

    $scope.updateOrderByFields = function(field, $event) {
      multisort.updateOrderByFields($scope, field, $event);
      $scope.cdash.builds = $filter('orderBy')($scope.cdash.builds, $scope.orderByFields);
      $scope.pageChanged();
      $.cookie('cdash_query_tests_sort', $scope.orderByFields);
    };

    $scope.numTestsPerPageChanged = function() {
      $.cookie("queryTests_num_per_page", $scope.pagination.numPerPage, { expires: 365 });
      $scope.pageChanged();
    };

    $scope.toggleShowMatchingOutput = function() {
      $scope.cdash.showmatchingoutput = !($scope.cdash.showmatchingoutput);
    };

});

CDash.controller('SubProjectController', function SubProjectController($scope, $rootScope, $http) {
  $scope.dataLoaded = false;

  $scope.loadData = function(id) {
    if ($scope.dataLoaded) {
      // Data already loaded, no need to do it again.
      return;
    }
    else {
      $rootScope.queryString['subprojectid'] = id;
      $http({
        url: 'api/v1/subproject.php',
        method: 'GET',
        params: $rootScope.queryString
      }).then(function success(s) {
        $scope.details = s.data;

        // Create a reference to this subproject's group.
        var index = -1;
        for(var i = 0, len = $scope.cdash.groups.length; i < len; i++) {
          if ($scope.cdash.groups[i].id === $scope.details.group) {
            $scope.details.group = $scope.cdash.groups[i];
            break;
          }
        }

        $scope.dataLoaded = true;
      });
    }
  };

  $scope.deleteSubProject = function(id) {
    var parameters = {
      projectid: $scope.details.projectid,
      subprojectid: id
    };

    $http({
      url: 'api/v1/subproject.php',
      method: 'DELETE',
      params: parameters
    }).then(function success() {
      // Find the index of the subproject to remove.
      var index = -1;
      for(var i = 0, len = $scope.cdash.subprojects.length; i < len; i++) {
        if ($scope.cdash.subprojects[i].id === id) {
          index = i;
          break;
        }
      }
      if (index > -1) {
        // Remove the subproject from our scope.
        $scope.cdash.subprojects.splice(index, 1);
      }
    });
  };

  $scope.addDependency = function(dependency, subprojectId) {
    var parameters = {
      projectid: $scope.details.projectid,
      subprojectid: subprojectId,
      dependencyid: dependency.id
    };

    $http({
      url: 'api/v1/subproject.php',
      method: 'PUT',
      params: parameters
    }).then(function success() {
      // Find the index of the dependency we just added.
      var index = -1;
      for(var i = 0, len = $scope.details.available_dependencies.length; i < len; i++) {
        if ($scope.details.available_dependencies[i].id === dependency.id) {
          index = i;
          break;
        }
      }
      if (index > -1) {
        // Remove this subproject from our list of available dependencies.
        var added = $scope.details.available_dependencies.splice(index, 1);
        // And add it to our list of dependencies.
        $scope.details.dependencies.push(added[0]);
      }
    });
  };

  $scope.removeDependency = function(dependencyId, subprojectId) {
    var parameters = {
      projectid: $scope.details.projectid,
      subprojectid: subprojectId,
      dependencyid: dependencyId
    };

    $http({
      url: 'api/v1/subproject.php',
      method: 'DELETE',
      params: parameters
    }).then(function success() {
      // Find the index of the dependency to remove.
      var index = -1;
      for(var i = 0, len = $scope.details.dependencies.length; i < len; i++) {
        if ($scope.details.dependencies[i].id === dependencyId) {
          index = i;
          break;
        }
      }
      if (index > -1) {
        // Remove this subproject from our list of dependencies.
        var removed = $scope.details.dependencies.splice(index, 1);
        // And add it to our list of potential dependencies.
        $scope.details.available_dependencies.push(removed[0]);
      }
    });
  };

  $scope.changeGroup = function() {
    var parameters = {
      projectid: $scope.details.projectid,
      subprojectid: $scope.details.subprojectid,
      groupname: $scope.details.group.name
    };
    $http({
      url: 'api/v1/subproject.php',
      method: 'PUT',
      params: parameters
    }).then(function success() {
      $("#group_changed_" + $scope.details.subprojectid).show();
      $("#group_changed_" + $scope.details.subprojectid).delay(3000).fadeOut(400);
    });
  };

});

CDash.controller('TestDetailsController',
  function TestDetailsController($scope, $http, $window, apiLoader) {
    apiLoader.loadPageData($scope, 'api/v1/testDetails.php');
    $scope.finishSetup = function() {
      $scope.cdash.showgraph = false;
      $scope.cdash.showcommandline = false;
      $scope.cdash.rawdatalink = '';
      if ($scope.queryString.graph) {
        $scope.cdash.graphSelection = $scope.queryString.graph;
        $scope.display_graph();
      }
    };

    $scope.toggle_commandline = function() {
      $scope.cdash.showcommandline = !($scope.cdash.showcommandline);
    };

    $scope.display_graph = function() {
      var testid = $scope.cdash.test.id;
      var buildid = $scope.cdash.test.buildid;
      var measurementname = $scope.cdash.graphSelection;
      if ($scope.cdash.graphSelection === "") {
        $scope.cdash.showgraph = false;
        $("#graph_options").html("");
        return;
      }

      $scope.cdash.showgraph = true;

      var query_params = {
        testid: testid,
        buildid: buildid
      };

      var graph_type = '';
      $scope.cdash.rawdatalink = 'api/v1/testGraph.php?testid=' + testid + '&buildid=' + buildid;
      switch ($scope.cdash.graphSelection) {
        case "status":
          graph_type = 'status';
          break;
        case "time":
          graph_type = 'time';
          break;
        default:
          graph_type = 'measurement';
          query_params.measurementname = measurementname;
          $scope.cdash.rawdatalink += '&measurementname=' + measurementname;
          break;
      }
      $scope.cdash.rawdatalink += '&type=' + graph_type;

      query_params.type = graph_type;
      $http({
        url: 'api/v1/testGraph.php',
        method: 'GET',
        params: query_params
      }).then(function success(s) {
        $scope.test_graph(s.data, graph_type);
      });

    };

    $scope.test_graph = function(response, graph_type) {
      // Separate out build & test ids from the actual data points.
      var buildids = {};
      var testids = {};
      var chart_data = [];
      for (var i = 0; i < response.length; i++) {
        var series = {};
        series.label = response[i].label;
        series.data = [];
        for (var j = 0; j < response[i].data.length; j++) {
          series.data.push([response[i].data[j]['x'], response[i].data[j]['y']]);
          if (i == 0) {
            buildids[response[i].data[j]['x']] = response[i].data[j]['buildid'];
            testids[response[i].data[j]['x']] = response[i].data[j]['testid'];
          }
        }
        chart_data.push(series);
      }

      // Options that are shared by all of our different types of charts.
      var options = {
        grid: {
          backgroundColor: "#fffaff",
          clickable: true,
          hoverable: true,
          hoverFill: '#444',
          hoverRadius: 4
        },
        pan: { interactive: true },
        zoom: { interactive: true, amount: 1.1 },
        xaxis: { mode: "time" },
        yaxis: {
          zoomRange: false,
          panRange: false
        }
      };

      switch (graph_type) {
        case "status":
          // Circles for passed tests, crosses for failed tests.
          chart_data[0].points = { symbol: 'circle'};
          chart_data[1].points = { symbol: 'cross'};
          options.series = {
            points: {
              show: true,
              radius: 5
            }
          };
          options.yaxis.ticks = [[-1, "Failed"], [1, "Passed"]];
          options.yaxis.min = -1.2;
          options.yaxis.max = 1.2;
          options.colors = ["#8aba5a", "#de6868"];
          break;

        case "time":
          // Show threshold series as a filled area.
          chart_data[1].lines = { fill: true };
          // The lack of a 'break' here is intentional.
          // time & measurement charts share common options.
        case "measurement":
          options.lines = { show: true };
          options.points = { show: true };
          options.colors = ["#0000FF", "#dba255", "#919733"];
          break;
      }

      $("#graph_holder").bind("plotclick", function (e, pos, item) {
        if (item) {
          plot.highlight(item.series, item.datapoint);
          buildid = buildids[item.datapoint[0]];
          testid = testids[item.datapoint[0]];
          var url = "testDetails.php?test=" + testid + "&build=" + buildid + "&graph=" + $scope.cdash.graphSelection;
          $window.open(url);
        }
       });

      plot = $.plot(
        $("#graph_holder"), chart_data, options);

      // Show tooltip on hover.
      date_formatter = d3.time.format("%b %d, %I:%M:%S %p");
      $("#graph_holder").bind("plothover", function (event, pos, item) {
        if (item) {
          var x = date_formatter(new Date(item.datapoint[0])),
              y = item.datapoint[1].toFixed(2);

          $("#tooltip").html(
              "<b>" + x + "</b><br/>" +
              item.series.label + ": <b>" + y + "</b>")
            .css({top: item.pageY+5, left: item.pageX+5})
            .fadeIn(200);
        } else {
          $("#tooltip").hide();
        }
      });
    };

    $scope.setup_compare = function() {
      $('.je_compare').je_compare({caption: true});
    };
});

CDash.controller('TestOverviewController',
  function TestOverviewController($scope, $rootScope, $filter, apiLoader, filters, multisort) {
    $scope.groupChanged = false;

    // Hide filters by default.
    $scope.showfilters = false;

    // Check for filters.
    $rootScope.queryString['filterstring'] = filters.getString();

    // Handle sort order.
    var sort_order = [];
    // First check if one was specified via query string.
    if ('sort' in $rootScope.queryString) {
      sort_order = $rootScope.queryString.sort.split(",");
    } else {
      // Next check for a sort order cookie.
      var sort_cookie_value = $.cookie('cdash_test_overview_sort');
      if(sort_cookie_value) {
        sort_order = sort_cookie_value.split(",");
      } else {
        // Default sorting: put the most broken tests at the top of the list.
        sort_order = ['-failpercent'];
      }
    }
    $scope.orderByFields = sort_order;

    // Pagination settings.
    $scope.pagination = [];
    $scope.pagination.filteredTests = [];
    $scope.pagination.currentPage = 1;
    $scope.pagination.maxSize = 5;

    // Check if we have a cookie for number of tests to display.
    var num_per_page_cookie = $.cookie('testOverview_num_per_page');
    if(num_per_page_cookie) {
      $scope.pagination.numPerPage = parseInt(num_per_page_cookie);
    } else {
      $scope.pagination.numPerPage = 10;
    }

    apiLoader.loadPageData($scope, 'api/v1/testOverview.php');

    $scope.finishSetup = function() {
      $scope.cdash.showpassedinitialvalue = $scope.cdash.showpassed;
      $scope.cdash.tests = $filter('orderBy')($scope.cdash.tests, $scope.orderByFields);
      $scope.pageChanged();

      // Group selection.
      var idx = $scope.cdash.groups.map(function(x) {return x.id; }).indexOf($scope.cdash.groupid);
      if (idx < 0) {
        idx = 0;
      }
      $scope.cdash.selectedGroup = $scope.cdash.groups[idx];
    };

    $scope.pageChanged = function() {
      var begin = (($scope.pagination.currentPage - 1) * $scope.pagination.numPerPage)
      , end = begin + $scope.pagination.numPerPage;
      if (end > 0) {
        $scope.pagination.filteredTests = $scope.cdash.tests.slice(begin, end);
      } else {
        $scope.pagination.filteredTests = $scope.cdash.tests;
      }
    };

    $scope.numTestsPerPageChanged = function() {
      $.cookie("testOverview_num_per_page", $scope.pagination.numPerPage, { expires: 365 });
      $scope.pageChanged();
    };

    $scope.showfilters_toggle = function() {
      $scope.showfilters = !$scope.showfilters;
      filters.toggle($scope.showfilters);
    };

    $scope.updateOrderByFields = function(field, $event) {
      multisort.updateOrderByFields($scope, field, $event);
      $scope.cdash.tests = $filter('orderBy')($scope.cdash.tests, $scope.orderByFields);
      $scope.pageChanged();
      $.cookie('cdash_test_overview_sort', $scope.orderByFields);
    };

    $scope.updateSelection = function() {
      var uri = '//' + location.host + location.pathname + '?project=' + $scope.cdash.projectname_encoded;
      // Include date range from time chart.
      if ($scope.cdash.begin_date == $scope.cdash.end_date) {
        uri += '&date=' + $scope.cdash.begin_date;
      } else {
        uri += '&begin=' + $scope.cdash.begin_date + '&end=' + $scope.cdash.end_date;
      }
      if ($scope.cdash.selectedGroup.id > 0) {
        uri += '&group=' + $scope.cdash.selectedGroup.id;
      }
      if ($scope.cdash.showpassed == 1) {
        uri += '&showpassed=1';
      }
      uri += filters.getString();
      window.location = uri;
    };
});

CDash.controller('TestSummaryController',
  function TestSummaryController($scope, apiLoader, multisort) {
    // Hide filters and graph by default.
    $scope.showfilters = false;
    $scope.showgraph = false;
    $scope.graphurl = '';

    // Check for sort order cookie.
    var sort_order = [];
    var sort_cookie_value = $.cookie('cdash_test_summary_sort');
    if(sort_cookie_value) {
      sort_order = sort_cookie_value.split(",");
    } else {
      // Default sorting : status then site.
      sort_order = ['status', 'site'];
    }
    $scope.orderByFields = sort_order;

    apiLoader.loadPageData($scope, 'api/v1/testSummary.php');
    $scope.finishSetup = function() {
      $scope.graphurl = $scope.failureGraphUrl();
    };

    $scope.updateOrderByFields = function(field, $event) {
      multisort.updateOrderByFields($scope, field, $event);
      $.cookie('cdash_test_summary_sort', $scope.orderByFields);
    };

    $scope.failureGraphUrl = function() {
      return 'ajax/showtestfailuregraph.php?testname=' + $scope.cdash.testName + '&projectid=' + $scope.cdash.projectid + '&starttime=' + $scope.cdash.currentstarttime;
    };

    $scope.resetZoom = function() {
      // ng-include won't reload if graphurl doesn't change, so simply
      // twiddle between URLs.
      if ($scope.graphurl.indexOf("zoomout") != -1) {
        $scope.graphurl = $scope.failureGraphUrl();
      } else {
        $scope.graphurl = $scope.failureGraphUrl() + "&zoomout=1";
      }
    };

});

CDash.controller('UserController', function UserController($scope, $http, $timeout, apiLoader) {
  apiLoader.loadPageData($scope, 'api/v1/user.php');

  $scope.generateToken = function() {
    var parameters = { description: $scope.cdash.tokendescription };
    $http.post('api/v1/authtoken.php', parameters)
    .then(function success(s) {
      var authtoken = s.data.token;
      authtoken.copied = false;
      $scope.cdash.authtokens.push(authtoken);
    }, function error(e) {
      $scope.cdash.message = e.data.error;
    });
  };

  $scope.copyTokenSuccess = function(token) {
    token.copied = true;
    token.showcheck = true;
    $timeout(function() {
      token.showcheck = false;
    }, 2000);
  };

  $scope.revokeToken = function(authtoken) {
    var parameters = { hash: authtoken.hash };
    $http({
      url: 'api/v1/authtoken.php',
      method: 'DELETE',
      params: parameters
    }).then(function success() {
      // Remove this token from our list.
      var index = -1;
      for(var i = 0, len = $scope.cdash.authtokens.length; i < len; i++) {
        if ($scope.cdash.authtokens[i].hash === authtoken.hash) {
          index = i;
          break;
        }
      }
      if (index > -1) {
        $scope.cdash.authtokens.splice(index, 1);
      }
    }, function error(e) {
      $scope.cdash.message = e.data.error;
    });
  };
});

CDash.controller('UserStatisticsController',
  function UserStatisticsController($scope, $filter, apiLoader, multisort) {
    // Check for sort order cookie.
    var sort_order = [];
    var sort_cookie_value = $.cookie('cdash_user_stats_sort');
    if(sort_cookie_value) {
      sort_order = sort_cookie_value.split(",");
    } else {
      // Default sorting priority.  The goal here is to put the most active
      // and helpful developers at the top of the list, with an emphasis
      // towards rewarding good behavior as opposed to punishing errors.
      sort_order = ['-totalupdatedfiles', '-fixed_errors', '-fixed_warnings',
                    '-fixed_tests', 'failed_errors', 'failed_warnings',
                    'failed_tests'];
    }
    $scope.orderByFields = sort_order;

    apiLoader.loadPageData($scope, 'api/v1/userStatistics.php');
    $scope.finishSetup = function() {
      $scope.cdash.users = $filter('orderBy')($scope.cdash.users, $scope.orderByFields);
    };

    $scope.defaultSorting = function() {
      $scope.orderByFields =
        ['-totalupdatedfiles', '-fixed_errors', '-fixed_warnings',
         '-fixed_tests', 'failed_errors', 'failed_warnings', 'failed_tests'];
      $scope.cdash.users = $filter('orderBy')($scope.cdash.users, $scope.orderByFields);
      $.cookie('cdash_user_stats_sort', null);
    };

    $scope.updateOrderByFields = function(field, $event) {
      multisort.updateOrderByFields($scope, field, $event);
      $scope.cdash.users = $filter('orderBy')($scope.cdash.users, $scope.orderByFields);
      $.cookie('cdash_user_stats_sort', $scope.orderByFields);
    };
});

CDash.controller('ViewBuildErrorController',
  function BuildErrorController($scope, $sce, apiLoader) {
    $scope.loading = true;
    $scope.pagination = [];
    $scope.pagination.buildErrors = [];
    $scope.pagination.currentPage = 1;
    $scope.pagination.numPerPage = 25;
    $scope.pagination.maxSize = 5;

    apiLoader.loadPageData($scope, 'api/v1/viewBuildError.php');
    $scope.finishSetup = function() {
      $scope.setPage(1);
    };

    $scope.setPage = function (pageNo) {
      var begin = ((pageNo - 1) * $scope.pagination.numPerPage),
          end = begin + $scope.pagination.numPerPage;

        if (end > 0) {
            $scope.pagination.buildErrors = $scope.cdash.errors.slice(begin, end);
        } else {
            $scope.pagination.buildErrors = $scope.cdash.errors;
        }
    };

    $scope.pageChanged = function() {
      $scope.setPage($scope.pagination.currentPage);
    };
  }).directive('buildError', function (VERSION) {
      return {
          templateUrl: 'build/views/partials/buildError_' + VERSION + '.html'
      };
  });

CDash.controller('ViewDynamicAnalysisController',
  function ViewDynamicAnalysisController($scope, apiLoader) {
    apiLoader.loadPageData($scope, 'api/v1/viewDynamicAnalysis.php');
});

CDash.controller('ViewDynamicAnalysisFileController',
  function ViewDynamicAnalysisFileController($scope, apiLoader) {
    apiLoader.loadPageData($scope, 'api/v1/viewDynamicAnalysisFile.php');
});

function ViewNotesController($scope, $location, anchors, apiLoader) {
  apiLoader.loadPageData($scope, 'api/v1/viewNotes.php');
  $scope.finishSetup = function() {
    // Honor any intra-page anchor specified in the URI.
    if ($location.hash() != '') {
    anchors.jumpToAnchor($location.hash());
    }
  };

  $scope.gotoNote = function(x) {
    var newHash = 'note' + x;
    anchors.jumpToAnchor(newHash);
  };
}

CDash.controller('ViewNotesController', ['$scope', '$location', 'anchors', 'apiLoader',
                                          ViewNotesController]);

CDash.controller('ViewProjectsController',
  function ViewProjectsController($scope, apiLoader) {
    // Hide filters by default.
    $scope.showfilters = false;
    apiLoader.loadPageData($scope, 'api/v1/viewProjects.php');
});

CDash.controller('ViewSubProjectsController',
  function ViewSubProjectsController($scope, multisort, apiLoader) {
    // Hide filters by default.
    $scope.showfilters = false;

    // Check for sort order cookie.
    var sort_order = [];
    var sort_cookie_value = $.cookie('cdash_subproject_sort');
    if(sort_cookie_value) {
      sort_order = sort_cookie_value.split(",");
    }
    $scope.sortSubProjects = { orderByFields: sort_order };

    apiLoader.loadPageData($scope, 'api/v1/viewSubProjects.php');

    $scope.updateOrderByFields = function(obj, field, $event) {
      multisort.updateOrderByFields(obj, field, $event);
      $.cookie('cdash_subproject_sort', obj.orderByFields);
    };
});

CDash.controller('ViewTestController',
  function ViewTestController($scope, $rootScope, $http, $filter, $q, apiLoader, multisort, filters) {
    $scope.loading = true;

    // Pagination settings.
    $scope.pagination = [];
    $scope.pagination.filteredTests = [];
    $scope.pagination.currentPage = 1;
    $scope.pagination.maxSize = 5;

    // Check if we have a cookie for number of tests to display.
    var num_per_page_cookie = $.cookie('viewTest_num_per_page');
      if(num_per_page_cookie) {
        $scope.pagination.numPerPage = parseInt(num_per_page_cookie);
      } else {
        $scope.pagination.numPerPage = 25;
      }

    // Hide filters by default.
    $scope.showfilters = false;

    // Check for filters
    $rootScope.queryString['filterstring'] = filters.getString();

    // Check for sort order cookie.
    var sort_order = [];
    var sort_cookie_value = $.cookie('cdash_view_test_sort');
    if(sort_cookie_value) {
      sort_order = sort_cookie_value.split(",");
    } else {
      // Default sorting : failed tests in alphabetical order.
      sort_order = ['subprojectname', 'status', 'name'];
    }
    $scope.orderByFields = sort_order;

    // Mechanism to cancel the summary/history AJAX query if the user loads another page.
    $scope.canceler = $q.defer();

    apiLoader.loadPageData($scope, 'api/v1/viewTest.php');
    $scope.finishSetup = function() {
      // Check for label filters
      $scope.cdash.extrafilterurl = filters.getLabelString($scope.cdash.filterdata);
      $scope.cdash.tests = $filter('orderBy')($scope.cdash.tests, $scope.orderByFields);
      $scope.setPage(1);
    };

    $scope.showfilters_toggle = function() {
      $scope.showfilters = !$scope.showfilters;
      filters.toggle($scope.showfilters);
    };

    $scope.setPage = function (pageNo) {
      var begin = ((pageNo - 1) * $scope.pagination.numPerPage)
      , end = begin + $scope.pagination.numPerPage;
      if (end > 0) {
        $scope.pagination.filteredTests = $scope.cdash.tests.slice(begin, end);
      } else {
        $scope.pagination.filteredTests = $scope.cdash.tests;
      }

      // Load history & summary data for these newly revealed tests (if necessary).
      var tests_to_load = [];
      for (var i = 0, len = $scope.pagination.filteredTests.length; i < len; i++) {
        if ( !('detailsloaded' in $scope.pagination.filteredTests[i]) ) {
          tests_to_load.push($scope.pagination.filteredTests[i]['name']);
        }
      }

      if (tests_to_load.length > 0) {
        $http({
          url: 'api/v1/viewTest.php',
          method: 'GET',
          params: {
            'tests[]': tests_to_load,
            'previous_builds': $scope.cdash.previous_builds,
            'time_begin': $scope.cdash.time_begin,
            'time_end': $scope.cdash.time_end,
            'projectid': $scope.cdash.projectid,
            'groupid': $scope.cdash.groupid
          },
          timeout: $scope.canceler.promise
        }).then(function success(s) {
          var response = s.data;
          $scope.cdash.displayhistory = $scope.cdash.displayhistory || response.displayhistory;
          $scope.cdash.displaysummary = $scope.cdash.displaysummary || response.displaysummary;

          function copy_test_details(test, response) {

            // Don't display extra data for missing tests
            if (test['status'] === 'Missing') {
                return;
            }

            if ('history' in response) {
              test['history'] = response['history'];
              test['historyclass'] = response['historyclass'];
            }
            if ('summary' in response) {
              test['summary'] = response['summary'];
              test['summaryclass'] = response['summaryclass'];
            }
            test['detailsloaded'] = true;
          }

          // Update our currently displayed filtered results with this new data.
          for (var i = 0, len1 = response.tests.length; i < len1; i++) {
            for (var j = 0, len2 = $scope.pagination.filteredTests.length; j < len2; j++) {
              if (response.tests[i].name === $scope.pagination.filteredTests[j].name) {
                copy_test_details($scope.pagination.filteredTests[j], response.tests[i]);
              }
            }
          }

          // Also copy this newfound data into the 'master list' of tests.
          for (var i = 0, len1 = response.tests.length; i < len1; i++) {
            for (var j = 0, len2 = $scope.cdash.tests.length; j < len2; j++) {
              if (response.tests[i].name === $scope.cdash.tests[j].name) {
                copy_test_details($scope.cdash.tests[j], response.tests[i]);
              }
            }
          }
        });
      }
    };

    $scope.pageChanged = function() {
      $scope.setPage($scope.pagination.currentPage);
    };

    $scope.updateOrderByFields = function(field, $event) {
      multisort.updateOrderByFields($scope, field, $event);
      $scope.cdash.tests = $filter('orderBy')($scope.cdash.tests, $scope.orderByFields);
      $scope.pageChanged();
      $.cookie('cdash_view_test_sort', $scope.orderByFields);
    };

    $scope.sortByExtraMeasurement = function(idx, $event) {
      var field = 'measurements[' + idx + ']';
      $scope.updateOrderByFields(field, $event);
    }

    $scope.numTestsPerPageChanged = function() {
      $.cookie("viewTest_num_per_page", $scope.pagination.numPerPage, { expires: 365 });
      $scope.pageChanged();
    };

    $scope.cancelAjax = function() {
      $scope.canceler.resolve();
    }
});

CDash.controller('ViewUpdateController',
  function ViewUpdateController($scope, $rootScope, $http, apiLoader) {
    $scope.graphLoaded = false;
    $scope.graphLoading = false;
    $scope.showGraph = false;
    apiLoader.loadPageData($scope, 'api/v1/viewUpdate.php');

    $scope.toggleGraph = function() {
      $scope.showGraph = !$scope.showGraph;
      if (!$scope.graphLoaded) {
        $scope.loadGraph();
      }
    };

    $scope.loadGraph = function() {
      $scope.graphLoading = true;
      $http({
        url: 'api/v1/buildUpdateGraph.php',
        method: 'GET',
        params: {
          buildid: $scope.cdash.build.buildid
        }
      }).then(function success(s) {
        $scope.initializeGraph(s.data);
        $scope.graphLoaded = true;
        $scope.graphLoading = false;
      });
    };

    $scope.initializeGraph = function(input) {
      var options = {
        lines: {show: true},
        points: {show: true},
        xaxis: {mode: "time"},
        grid: {
          backgroundColor: "#fffaff",
          clickable: true,
          hoverable: true,
          hoverFill: '#444',
          hoverRadius: 4
        },
        selection: {mode: "x"},
        colors: ["#0000FF", "#dba255", "#919733"]
      };

      $("#graph_holder").bind("selected", function (event, area) {
        plot = $.plot($("#graph_holder"), [{
          label: "Number of changed files",
          data: input.data
        }], $.extend(true, {}, options, {xaxis: {min: area.x1, max: area.x2}}));
      });

      $("#graph_holder").bind("plotclick", function (e, pos, item) {
        if (item) {
          plot.highlight(item.series, item.datapoint);
          buildid = input.buildids[item.datapoint[0]];
          window.location = "build/" + buildid;
        }
      });

      plot = $.plot($("#graph_holder"), [{label: "Number of changed files", data: input.data}], options);
    };
})

.directive('updatedFiles', function(VERSION) {
  return {
    templateUrl: 'build/views/partials/updatedfiles_' + VERSION + '.html'
  }
});
